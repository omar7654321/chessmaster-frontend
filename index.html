<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChessMaster - Black vs White</title>
    <style>
        :root {
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight: rgba(255, 255, 0, 0.4);
            --selected: rgba(0, 255, 0, 0.4);
            --white-player: #f8f9fa;
            --black-player: #343a40;
            --white-piece: #ffffff;
            --black-piece: #000000;
        }

        .hidden {
            display: none !important;
        }

        .puzzle-field-column {
            display: flex;
            flex-direction: column;
        }

        .puzzle-game-link {
            color: #58d68d;
        }

        .captured-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .captured-row--spaced {
            margin-bottom: 1rem;
        }

        .captured-label {
            min-width: 70px;
            color: #ecf0f1;
        }

        .captured-list {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        #gameHistoryMeta {
            font-size: 0.85rem;
            color: #bdc3c7;
            font-weight: 400;
        }

        .analysis-panel {
            margin-top: 1.5rem;
            background: rgba(34, 47, 62, 0.9);
            border: 1px solid rgba(241, 196, 15, 0.35);
            border-radius: 10px;
            padding: 1rem;
        }

        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }

        .analysis-title {
            margin: 0;
            font-size: 1.3rem;
            color: #f1c40f;
        }

        .analysis-toggle {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            border: 1px solid #f1c40f;
            background: transparent;
            color: #f1c40f;
            cursor: pointer;
        }

        .analysis-status {
            margin-top: 0.75rem;
            color: #bdc3c7;
            font-size: 0.95rem;
        }

        .analysis-score {
            margin-top: 0.5rem;
            font-size: 1.1rem;
            color: #ecf0f1;
        }

        .analysis-depth {
            margin-top: 0.25rem;
            font-size: 0.95rem;
            color: #bdc3c7;
        }

        .analysis-lines {
            margin-top: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .analysis-lines-row,
        .fen-tools-row,
        .pgn-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .fen-input {
            flex: 1;
            min-width: 260px;
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid #5d6d7e;
            background: #22313f;
            color: #ecf0f1;
        }

        .pgn-input-group {
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .pgn-input,
        .move-comment-text {
            width: 100%;
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid #5d6d7e;
            background: #22313f;
            color: #ecf0f1;
        }

        .pgn-speed-label {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .pgn-speed-input {
            width: 80px;
            padding: 0.25rem;
            border-radius: 6px;
            border: 1px solid #5d6d7e;
            background: #22313f;
            color: #ecf0f1;
        }

        .pgn-variations {
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .move-comment-section {
            margin-top: 0.5rem;
        }

        .move-comment-title {
            color: #f1c40f;
            margin: 0.25rem 0;
        }

        .move-comment-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .modal-actions {
            margin-top: 0.75rem;
        }

        .game-history-panel {
            margin-top: 1.5rem;
            background: rgba(30, 42, 56, 0.85);
            border: 1px solid rgba(241, 196, 15, 0.35);
            border-radius: 10px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .game-history-panel h2 {
            margin: 0;
            font-size: 1.4rem;
            color: #f1c40f;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .game-history-toolbar {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .game-history-table-wrapper {
            max-height: 280px;
            overflow: auto;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .game-history-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(19, 27, 37, 0.95);
        }

        .game-history-table th,
        .game-history-table td {
            padding: 0.55rem 0.7rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            text-align: left;
            font-size: 0.9rem;
        }

        .game-history-table th {
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.75rem;
            color: #f9e79f;
            position: sticky;
            top: 0;
            background: rgba(25, 34, 46, 0.95);
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
        }

        .game-history-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: #bdc3c7;
            font-size: 0.95rem;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #2c3e50, #4a6572);
            color: #ecf0f1;
            line-height: 1.6;
            min-height: 100vh;
        }
        
        header {
            background-color: rgba(52, 73, 94, 0.9);
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border-bottom: 3px solid #f1c40f;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 0.5rem;
            color: #f1c40f;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .global-nav {
            margin-top: 1.25rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .global-nav a {
            padding: 0.55rem 1.25rem;
            border-radius: 999px;
            background: rgba(46, 64, 83, 0.85);
            border: 1px solid rgba(241, 196, 15, 0.6);
            color: #ecf0f1;
            font-weight: 600;
            text-decoration: none;
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
        }
        
        .global-nav a:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
            background: rgba(52, 73, 94, 0.9);
        }
        
        .global-nav a:focus-visible {
            outline: 3px solid #f1c40f;
            outline-offset: 2px;
        }
        
        .auth-controls {
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .auth-status {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.45rem 0.85rem;
            border-radius: 999px;
            background: rgba(33, 47, 61, 0.8);
            border: 1px solid rgba(241, 196, 15, 0.45);
            font-size: 0.95rem;
        }

        .auth-status strong {
            color: #f1c40f;
        }

        .auth-button {
            padding: 0.45rem 1rem;
            border-radius: 999px;
            background: rgba(34, 153, 84, 0.85);
            border: 1px solid rgba(46, 204, 113, 0.65);
            color: #ecf0f1;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        .auth-button.secondary {
            background: rgba(52, 73, 94, 0.85);
            border-color: rgba(127, 140, 141, 0.6);
        }

        .auth-button:hover {
            transform: translateY(-2px);
            background: rgba(34, 153, 84, 0.95);
        }

        .auth-button.secondary:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        .auth-modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(10, 13, 18, 0.72);
            -webkit-backdrop-filter: blur(3px);
            backdrop-filter: blur(3px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .auth-modal-backdrop.visible {
            display: flex;
        }

        .auth-modal {
            background: linear-gradient(135deg, rgba(34, 47, 62, 0.92), rgba(25, 30, 40, 0.96));
            border: 1px solid rgba(241, 196, 15, 0.35);
            border-radius: 12px;
            width: min(420px, 92vw);
            padding: 1.75rem 1.5rem 1.5rem;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .auth-modal h2 {
            margin: 0 0 0.5rem;
            color: #f1c40f;
            text-align: center;
            font-size: 1.8rem;
        }

        .auth-modal .auth-toggle {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .auth-toggle button {
            padding: 0.5rem 1.1rem;
            border-radius: 999px;
            border: 1px solid rgba(241, 196, 15, 0.35);
            background: rgba(52, 73, 94, 0.75);
            color: #ecf0f1;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }

        .auth-toggle button.active {
            background: rgba(241, 196, 15, 0.85);
            color: #1b2631;
            transform: translateY(-1px);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form label {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            font-size: 0.95rem;
            gap: 0.3rem;
        }

        .auth-form input {
            padding: 0.55rem 0.65rem;
            border-radius: 8px;
            border: 1px solid rgba(189, 195, 199, 0.4);
            background: rgba(33, 47, 61, 0.85);
            color: #ecf0f1;
            font-size: 1rem;
        }

        .auth-form input:focus-visible {
            outline: 3px solid rgba(241, 196, 15, 0.35);
            outline-offset: 0;
        }

        .auth-form .form-actions {
            display: flex;
            justify-content: space-between;
            gap: 0.6rem;
            margin-top: 1.5rem;
        }

        .auth-form .form-actions button {
            flex: 1;
        }

        .auth-error {
            color: #e74c3c;
            font-size: 0.9rem;
            text-align: center;
        }

        .auth-success {
            color: #2ecc71;
            font-size: 0.9rem;
            text-align: center;
        }

        .auth-close {
            position: absolute;
            top: 0.75rem;
            right: 0.85rem;
            background: transparent;
            border: none;
            color: #bdc3c7;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .auth-close:hover {
            color: #f1c40f;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            justify-content: center;
        }
        
        .game-section {
            flex: 2;
            min-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .players-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-bottom: 1.5rem;
        }
        
        .player {
            padding: 1rem 1.5rem;
            border-radius: 10px;
            text-align: center;
            width: 45%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .player.active {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }
        
        .player.white {
            background-color: var(--white-player);
            color: #333;
            border: 3px solid #f1c40f;
        }
        
        .player.black {
            background-color: var(--black-player);
            color: #fff;
            border: 3px solid #f1c40f;
        }
        
        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        .player.active .player-name::after {
            content: " (Moving)";
            color: #e74c3c;
            font-weight: normal;
        }
        
        .board-eval-container {
            width: 100%;
            max-width: 600px;
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: stretch;
        }

        .chessboard {
            flex: 1 1 auto;
            max-width: 540px;
            margin: 0;
            border: 12px solid #5d6d7e;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background-color: #5d6d7e;
            transition: transform 0.25s ease;
        }

        .engine-eval-bar {
            width: 40px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.18);
            background: #000000;
            position: relative;
            display: none;
            overflow: hidden;
        }

        .engine-eval-bar.visible {
            display: block;
        }

        .engine-eval-fill {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 50%;
            background: #ffffff;
            transition: height 140ms ease;
        }

        .engine-eval-label {
            position: absolute;
            left: 50%;
            transform: translate(-50%, 50%);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: #ecf0f1;
            font-size: 0.75rem;
            font-weight: 600;
            white-space: nowrap;
            pointer-events: none;
        }

        .evaluation-graph-panel {
            margin-top: 1.25rem;
            background: rgba(34, 47, 62, 0.9);
            border: 1px solid rgba(241, 196, 15, 0.25);
            border-radius: 10px;
            padding: 1rem 1.2rem 1.2rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .evaluation-graph-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            color: #f1c40f;
        }

        .evaluation-graph-header h2 {
            margin: 0;
            font-size: 1.2rem;
            color: inherit;
        }

        .evaluation-graph-latest {
            font-size: 0.95rem;
            color: #ecf0f1;
            background: rgba(0, 0, 0, 0.45);
            border-radius: 999px;
            padding: 0.25rem 0.65rem;
        }

        .evaluation-graph-body {
            position: relative;
        }

        .evaluation-graph-body canvas {
            width: 100%;
            height: 180px;
            display: none;
            border-radius: 8px;
        }

        .evaluation-graph-empty {
            color: #bdc3c7;
            font-size: 0.95rem;
            text-align: center;
            padding: 1.2rem 0.5rem;
            border: 1px dashed rgba(189, 195, 199, 0.4);
            border-radius: 8px;
            background: rgba(52, 73, 94, 0.35);
        }

        @media (max-width: 768px) {
            .evaluation-graph-body canvas {
                height: 140px;
            }
        }

        .move-quality-indicator {
            position: absolute;
            top: 6px;
            right: 6px;
            font-size: 1.15rem;
            font-weight: 800;
            pointer-events: none;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
        }

        .move-quality-indicator.mistake {
            color: #f1c40f;
        }

        .move-quality-indicator.blunder {
            color: #e74c3c;
        }
        
        .board-row {
            display: flex;
        }
        
        .square {
            width: 12.5%;
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            transition: background-color 0.2s;
            font-size: 3.2rem;
            position: relative;
        }

        .square-label {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .square-label span {
            position: absolute;
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(23, 32, 42, 0.78);
            text-transform: uppercase;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.7);
            -webkit-user-select: none;
            user-select: none;
        }

        .rank-label.rank-left {
            top: 6px;
            left: 6px;
        }

        .rank-label.rank-right {
            bottom: 6px;
            right: 6px;
        }

        .file-label.file-bottom {
            bottom: 6px;
            right: 6px;
        }

        .file-label.file-top {
            top: 6px;
            left: 6px;
        }

        .chessboard.flipped .square-label {
            transform: none;
        }

        .chessboard.flipped .square-label span {
            transform: rotate(180deg);
        }

        .chessboard .file-label.file-top,
        .chessboard .rank-label.rank-right {
            display: none;
        }

        .chessboard.flipped .file-label.file-bottom,
        .chessboard.flipped .rank-label.rank-left {
            display: none;
        }

        .chessboard.flipped .file-label.file-top,
        .chessboard.flipped .rank-label.rank-right {
            display: inline-block;
        }

        .light {
            background-color: var(--light-square);
        }
        
        .dark {
            background-color: var(--dark-square);
        }
        
        .selected {
            background-color: var(--selected) !important;
        }
        
        .valid-move::after {
            content: "";
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        .capture-move::after {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            border: 4px solid rgba(231, 76, 60, 0.6);
            background-color: transparent;
        }
        
        /* Chess piece styles */
        .piece {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.3));
        }

        .captured-symbol {
            font-size: 1.8rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.8rem;
            height: 1.8rem;
            margin-right: 6px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4);
        }

        .captured-symbol.white {
            color: var(--white-piece);
            -webkit-text-stroke: 1px rgba(0, 0, 0, 0.3);
            filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.25));
        }

        .captured-symbol.black {
            color: var(--black-piece);
            -webkit-text-stroke: 1px rgba(255, 255, 255, 0.3);
            filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.4));
        }

        /* Move animation */
        .animate-piece { transition: transform 180ms ease; will-change: transform; }

        /* Last move highlight */
        .last-from { box-shadow: inset 0 0 0 4px rgba(241, 196, 15, 0.5); }
        .last-to { box-shadow: inset 0 0 0 4px rgba(46, 204, 113, 0.5); }

        /* Flipped board visuals */
        .chessboard.flipped { transform: rotate(180deg); transform-origin: center; }
        .chessboard.flipped .piece { transform: rotate(180deg); }
        
        .white-piece {
            color: var(--white-piece);
            -webkit-text-stroke: 1px rgba(0, 0, 0, 0.3);
        }
        
        .black-piece {
            color: var(--black-piece);
            -webkit-text-stroke: 1px rgba(255, 255, 255, 0.3);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
        }
        
        button {
            padding: 0.8rem 1.8rem;
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background: linear-gradient(to bottom, #2980b9, #2573a7);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .info-section {
            flex: 1;
            min-width: 350px;
            background-color: rgba(52, 73, 94, 0.8);
            padding: 1.8rem;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            border: 2px solid #f1c40f;
        }
        
        .move-history {
            margin-top: 1.5rem;
            max-height: 350px;
            overflow-y: auto;
            background-color: rgba(44, 62, 80, 0.7);
            padding: 1.2rem;
            border-radius: 8px;
            border: 1px solid #5d6d7e;
        }
        
        .move-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.7rem;
        }
        
        .move {
            padding: 0.5rem 0.7rem;
            background-color: #34495e;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        
        .move:hover {
            background-color: #3d566e;
        }
        
        .move.white-move {
            border-left: 4px solid var(--white-player);
        }
        
        .move.black-move {
            border-left: 4px solid var(--black-player);
        }
        
        h2 {
            color: #f1c40f;
            margin-bottom: 1.2rem;
            border-bottom: 2px solid #f1c40f;
            padding-bottom: 0.7rem;
            font-size: 1.6rem;
        }
        
        .status {
            margin-top: 1.5rem;
            padding: 1.2rem;
            background: linear-gradient(135deg, #34495e, #2c3e50);
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
            border: 2px solid #f1c40f;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .instructions {
            margin-top: 1.5rem;
            padding: 1.2rem;
            background-color: rgba(44, 62, 80, 0.7);
            border-radius: 8px;
        }
        
        .instructions p {
            margin-bottom: 0.8rem;
            padding-left: 1rem;
            border-left: 3px solid #f1c40f;
        }
        
        .special-moves {
            margin-top: 1.5rem;
            padding: 1.2rem;
            background-color: rgba(44, 62, 80, 0.7);
            border-radius: 8px;
        }
        
        .special-moves h3 {
            color: #f1c40f;
            margin-bottom: 0.8rem;
        }
        
        .special-moves p {
            margin-bottom: 0.8rem;
            padding-left: 1rem;
            border-left: 3px solid #3498db;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .puzzle-board-wrapper {
            position: relative;
            margin-top: 1.25rem;
        }

        .puzzle-board-overlay {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 8;
            pointer-events: none;
            min-width: 240px;
        }

        .puzzle-status-floating {
            background: linear-gradient(135deg, rgba(44, 62, 80, 0.94), rgba(30, 45, 60, 0.94));
            border: 2px solid #58d68d;
            border-radius: 10px;
            padding: 0.65rem 1.1rem;
            text-align: center;
            font-weight: 600;
            color: #ecf0f1;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
        }

        .puzzle-status-floating.is-error {
            border-color: #e74c3c;
            color: #fcefe9;
            background: linear-gradient(135deg, rgba(120, 46, 37, 0.94), rgba(99, 28, 28, 0.94));
        }

        .puzzle-success-modal {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            opacity: 0;
            pointer-events: none;
            transition: opacity 180ms ease;
            z-index: 12;
        }

        .puzzle-success-modal.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .puzzle-success-content {
            background: linear-gradient(135deg, #34495e, #22313f);
            border: 3px solid #58d68d;
            border-radius: 14px;
            padding: 1.5rem 2rem;
            color: #ecf0f1;
            text-align: center;
            box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45);
            max-width: 420px;
        }

        .puzzle-success-content h3 {
            margin-bottom: 0.75rem;
            font-size: 1.6rem;
            color: #58d68d;
        }

        .puzzle-success-content p {
            margin-bottom: 1.25rem;
            line-height: 1.5;
        }

        .puzzle-success-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .puzzle-success-actions button {
            min-width: 140px;
        }

        .confirm-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .confirm-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .confirm-box {
            background: #1f2a36;
            border-radius: 10px;
            padding: 1.5rem;
            max-width: 360px;
            width: 90%;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(241, 196, 15, 0.4);
        }

        .confirm-box h3 {
            margin-bottom: 0.75rem;
            font-size: 1.2rem;
            color: #f1c40f;
        }

        .confirm-box p {
            margin-bottom: 1.25rem;
            color: #ecf0f1;
            line-height: 1.5;
        }

        .confirm-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        .confirm-actions button {
            min-width: 110px;
        }

        .history-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1900;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .history-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .history-modal {
            background: #1b2735;
            border-radius: 12px;
            width: min(820px, 92vw);
            max-height: min(80vh, 680px);
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(241, 196, 15, 0.45);
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .history-modal header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background: rgba(44, 62, 80, 0.9);
            border-bottom: 1px solid rgba(241, 196, 15, 0.35);
        }

        .history-modal header h3 {
            margin: 0;
            font-size: 1.25rem;
            color: #f1c40f;
        }

        .history-modal header span {
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        .history-modal .history-body {
            padding: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .history-empty {
            text-align: center;
            padding: 2.5rem 1.5rem;
            color: #bdc3c7;
            font-size: 1rem;
        }

        .history-table-wrapper {
            flex: 1;
            overflow: auto;
            padding: 0.75rem 1.5rem 1.5rem;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .history-table thead {
            position: sticky;
            top: 0;
            background: rgba(27, 39, 53, 0.95);
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
        }

        .history-table th,
        .history-table td {
            padding: 0.6rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .history-table th {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.04em;
            color: #f9e79f;
        }

        .history-table tbody tr:hover {
            background: rgba(52, 73, 94, 0.45);
        }

        .history-result-success {
            color: #58d68d;
            font-weight: 600;
        }

        .history-result-fail {
            color: #e74c3c;
            font-weight: 600;
        }

        .history-modal footer {
            padding: 0.85rem 1.5rem;
            border-top: 1px solid rgba(241, 196, 15, 0.25);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            background: rgba(27, 39, 53, 0.9);
        }

        .hint-highlight-piece {
            box-shadow: inset 0 0 0 6px rgba(88, 214, 141, 0.7) !important;
        }

        .hint-highlight-target {
            box-shadow: inset 0 0 0 6px rgba(241, 196, 15, 0.7) !important;
        }

        .ai-modal-backdrop {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.65);
            z-index: 1200;
        }

        .ai-modal {
            width: min(540px, 92vw);
            background: linear-gradient(135deg, #273746, #1c2833);
            border: 3px solid #3498db;
            border-radius: 16px;
            padding: 1.8rem 2rem;
            color: #ecf0f1;
            box-shadow: 0 16px 34px rgba(0, 0, 0, 0.5);
        }

        .ai-modal h3 {
            margin: 0 0 1rem;
            font-size: 1.6rem;
            color: #5dade2;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .ai-modal-section {
            margin-bottom: 1.25rem;
        }

        .ai-modal-section-header {
            font-weight: 700;
            margin-bottom: 0.6rem;
            color: #f1c40f;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .ai-opponent-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .ai-opponent-card {
            border: 1px solid rgba(93, 173, 226, 0.5);
            border-radius: 12px;
            padding: 0.9rem 1rem;
            background: rgba(44, 62, 80, 0.55);
            display: flex;
            gap: 0.85rem;
            align-items: flex-start;
            transition: border 160ms ease, box-shadow 160ms ease, transform 160ms ease;
        }

        .ai-opponent-card input[type="radio"] {
            margin-top: 0.35rem;
        }

        .ai-opponent-card.active {
            border-color: #5dade2;
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
            transform: translateY(-2px);
            background: rgba(52, 73, 94, 0.7);
        }

        .ai-opponent-meta {
            flex: 1 1 auto;
        }

        .ai-opponent-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: #ecf0f1;
        }

        .ai-opponent-tags {
            margin-top: 0.35rem;
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .ai-tag {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.2rem 0.5rem;
            border-radius: 999px;
            border: 1px solid rgba(241, 196, 15, 0.6);
            color: #f9e79f;
            background: rgba(241, 196, 15, 0.1);
        }

        .ai-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .ai-side-options {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        .ai-side-options label {
            display: flex;
            gap: 0.4rem;
            align-items: center;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .game-section, .info-section {
                min-width: 100%;
            }
            
            .players-container {
                flex-direction: column;
                gap: 1rem;
            }
            
            .player {
                width: 100%;
            }
            
            .square {
                font-size: 2.5rem;
            }
        }

        /* Promotion modal */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            background: #2c3e50;
            border: 2px solid #f1c40f;
            border-radius: 10px;
            padding: 1rem;
            min-width: 280px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            color: #ecf0f1;
        }
        .modal h3 { margin-bottom: 0.75rem; color: #f1c40f; text-align: center; }
        .promo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem; }
        .promo-btn {
            padding: 0.8rem 0.6rem;
            background: #34495e;
            border: 2px solid #5d6d7e;
            border-radius: 8px;
            color: #ecf0f1;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.15s, background 0.2s;
        }
        .promo-btn:hover { background: #3d566e; transform: translateY(-2px); }
        .promo-icons { font-size: 1.4rem; display: block; }
        .modal-actions { margin-top: 0.75rem; text-align: center; }
        .modal-cancel { background: #7f8c8d; border: 2px solid #95a5a6; }
        .modal-cancel:hover { background: #95a5a6; }
    </style>
</head>
<body>
    <header>
        <h1>ChessMaster</h1>
        <nav class="global-nav" aria-label="Primary">
            <a id="navHome" href="#home">Home</a>
            <a id="navPlay" href="#play">Play</a>
            <a id="navComputer" href="#computer">Computer</a>
            <a id="navAnalysis" href="#analysis">Analysis</a>
            <a id="navAnalysisEngine" href="#analysis-engine">Engine</a>
            <a id="navPuzzles" href="#puzzles">Puzzles</a>
        </nav>
        <div class="auth-controls" role="navigation" aria-label="Account controls">
            <div id="authStatus" class="auth-status" hidden>
                Signed in as <strong id="authUsername">Guest</strong>
            </div>
            <button id="authLoginBtn" class="auth-button">Sign In</button>
            <button id="authLogoutBtn" class="auth-button secondary" hidden>Sign Out</button>
        </div>
    </header>

    <!-- Start Screen -->
    <style>
        .start-screen {
            max-width: 900px; margin: 2rem auto; text-align: center;
        }
        .start-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; }
        .start-card { background: #2c3e50; border: 2px solid #5d6d7e; border-radius: 10px; padding: 1rem; box-shadow: 0 8px 20px rgba(0,0,0,0.4); }
        .start-card h3 { color: #f1c40f; margin: 0.25rem 0 0.5rem; }
        .start-card p { color: #bdc3c7; min-height: 3.5em; }
        .start-card button { margin-top: 0.5rem; }
        .start-card a {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.8rem 1.8rem;
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }
        .start-card a:hover {
            background: linear-gradient(to bottom, #2980b9, #2573a7);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }
        .start-card a:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .online-play-panel {
            margin-top: 1.25rem;
            background: rgba(17, 24, 32, 0.9);
            border-radius: 0.75rem;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            border: 1px solid rgba(88, 214, 141, 0.25);
        }

        .online-play-panel.hidden {
            display: none !important;
        }

        .online-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .online-field select,
        .online-section input[type="text"] {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(10, 14, 20, 0.9);
            color: #ecf0f1;
            font-size: 0.95rem;
        }

        .online-field select:focus,
        .online-section input[type="text"]:focus {
            outline: none;
            border-color: #58d68d;
            box-shadow: 0 0 0 2px rgba(88, 214, 141, 0.25);
        }

        .online-join-row,
        .online-share-row {
            display: flex;
            gap: 0.5rem;
        }

        .online-join-row input,
        .online-share-row input {
            flex: 1 1 auto;
        }

        .online-status {
            font-size: 0.9rem;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            background: rgba(44, 62, 80, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .online-status.online-status-success {
            border-color: #58d68d;
            color: #58d68d;
        }

        .online-status.online-status-error {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .online-share,
        .online-actions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            padding-top: 0.5rem;
            border-top: 1px dashed rgba(236, 240, 241, 0.2);
        }

        .online-share.hidden,
        .online-actions.hidden {
            display: none !important;
        }

        .online-actions button {
            width: 100%;
        }

        .online-game-meta {
            font-size: 0.9rem;
            color: #bdc3c7;
        }
        .start-card a {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.8rem 1.8rem;
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }
        .start-card a:hover {
            background: linear-gradient(to bottom, #2980b9, #2573a7);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }
        .start-card a:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .puzzle-container {
            max-width: 1350px;
            width: 100%;
            margin: 2rem auto;
            background: #22313f;
            border: 2px solid #5d6d7e;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 10px 24px rgba(0,0,0,0.45);
        }
        .puzzle-container h2 { color: #f1c40f; margin-bottom: 1rem; text-align:center; }
        .puzzle-status { color: #ecf0f1; margin-bottom: 1.5rem; text-align:center; }
        .puzzle-details { display:flex; flex-direction:column; gap:1.5rem; margin-bottom:1.5rem; }
        .puzzle-header-row {
            display:flex;
            flex-wrap:wrap;
            gap:1.5rem;
            justify-content:space-between;
            align-items:stretch;
        }
        .puzzle-meta {
            flex:1 1 360px;
            display:grid;
            gap:0.75rem;
        }
        .puzzle-field { display:flex; flex-wrap:wrap; gap:0.5rem; color:#ecf0f1; }
        .puzzle-field strong { color:#f1c40f; }
        .puzzle-tags { display:flex; flex-wrap:wrap; gap:0.5rem; }
        .puzzle-tag { background: rgba(52, 73, 94, 0.85); padding:0.25rem 0.6rem; border-radius: 999px; border:1px solid #5d6d7e; font-size:0.85rem; }
        .puzzle-rating-card {
            flex:0 0 260px;
            background:rgba(34, 47, 62, 0.92);
            border:1px solid rgba(241,196,15,0.45);
            border-radius:12px;
            padding:1.25rem 1.5rem;
            box-shadow:0 10px 24px rgba(0,0,0,0.35);
            display:flex;
            flex-direction:column;
            gap:0.75rem;
        }
        .puzzle-rating-card h3 {
            margin:0;
            font-size:1.3rem;
            color:#f1c40f;
            text-transform:uppercase;
            letter-spacing:0.08em;
        }
        .puzzle-rating-value {
            font-size:2.6rem;
            font-weight:700;
            color:#ecf0f1;
            text-shadow:0 4px 12px rgba(0,0,0,0.45);
        }
        .puzzle-rating-delta {
            font-size:1.05rem;
            font-weight:600;
            color:#ecf0f1;
        }
        .puzzle-rating-note {
            font-size:0.9rem;
            color:#bdc3c7;
            line-height:1.45;
        }
        .puzzle-rating-trend-wrapper {
            display:flex;
            flex-direction:column;
            gap:0.4rem;
        }
        #puzzleRatingTrend {
            width:100%;
            height:110px;
            display:none;
            background:rgba(17, 24, 32, 0.75);
            border-radius:6px;
        }
        .puzzle-rating-trend-empty {
            font-size:0.85rem;
            color:#bdc3c7;
            text-align:center;
        }
        .puzzle-actions {
            display:flex;
            flex-wrap:wrap;
            gap:0.75rem;
            justify-content:center;
            margin:1.5rem 0 0;
        }
        .puzzle-actions button {
            padding: 0.65rem 1.5rem;
            border-radius: 8px;
            background: linear-gradient(to bottom, #27ae60, #1e8449);
            border: 2px solid #145a32;
            color: #ecf0f1;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .puzzle-actions button:hover { transform: translateY(-2px); box-shadow:0 6px 14px rgba(0,0,0,0.3); }
        .puzzle-actions button:active { transform: translateY(1px); }
        .puzzle-fen { background:#18222d; padding:0.35rem 0.55rem; border-radius:6px; border:1px solid #5d6d7e; font-family:'Consolas', 'Courier New', monospace; color:#f8f9fa; font-size:0.9rem; }
        #puzzleContainer #appContainer {
            margin-top: 1.5rem;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
            max-width: 1250px;
            background: rgba(27, 40, 55, 0.9);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 12px 28px rgba(0,0,0,0.4);
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            justify-content: center;
            align-items: flex-start;
        }
        #puzzleContainer #openInAnalysis { display: none !important; }
    </style>
    <div id="startScreen" class="start-screen">
        <h2>What would you like to do?</h2>
        <div class="start-grid">
            <div class="start-card" id="onlinePlayCard">
                <h3>Play Online</h3>
                <p>Challenge players around the world in real time.</p>
                <button id="btnPlayOnline">Open Online Lobby</button>
                <div id="onlinePlayPanel" class="online-play-panel hidden">
                    <div class="online-section">
                        <label for="onlineUsername">Display Name</label>
                        <input id="onlineUsername" type="text" placeholder="Guest" maxlength="20">
                    </div>
                    <div class="online-section">
                        <button id="onlineCreateBtn" class="primary">Create Game</button>
                        <div class="online-field">
                            <label for="onlineColor">Preferred Color</label>
                            <select id="onlineColor">
                                <option value="random">Random</option>
                                <option value="white">White</option>
                                <option value="black">Black</option>
                            </select>
                        </div>
                    </div>
                    <div class="online-section">
                        <label for="onlineJoinId">Join Game ID</label>
                        <div class="online-join-row">
                            <input id="onlineJoinId" type="text" placeholder="Enter Game ID" maxlength="12">
                            <button id="onlineJoinBtn">Join</button>
                        </div>
                    </div>
                    <div class="online-status" id="onlineStatus" role="status">Not connected</div>
                    <div class="online-share hidden" id="onlineShare">
                        <label for="onlineShareLink">Invite Link</label>
                        <div class="online-share-row">
                            <input id="onlineShareLink" type="text" readonly>
                            <button id="onlineCopyLink">Copy</button>
                        </div>
                        <div class="online-game-meta" id="onlineGameMeta"></div>
                    </div>
                    <div class="online-actions hidden" id="onlineInGameActions">
                        <span id="onlineTurnStatus">Waiting for opponent...</span>
                        <button id="onlineResignBtn" class="danger">Resign</button>
                        <button id="onlineLeaveBtn">Leave Game</button>
                    </div>
                </div>
            </div>
            <div class="start-card">
                <h3>Play on Same Device</h3>
                <p>Two players take turns on this device.</p>
                <a id="linkLocalPlay" href="#play">Start Local Game</a>
            </div>
            <div class="start-card">
                <h3>Play vs Computer</h3>
                <p>Face an AI opponent with configurable difficulty.</p>
                <a id="linkPlayComputer" href="#computer">Choose Opponent</a>
            </div>
            <div class="start-card">
                <h3>Analyze Game</h3>
                <p>Load FEN/PGN, step through moves, and analyze positions.</p>
                <a id="linkAnalyzeGame" href="#analysis">Open Analysis</a>
            </div>
            <div class="start-card">
                <h3>Analyze with Computer</h3>
                <p>Get engine insights on your game.</p>
                <button id="btnAnalyzeWithComputer">Launch Analysis</button>
            </div>
            <div class="start-card">
                <h3>Puzzles</h3>
                <p>Test your tactics with a curated challenge.</p>
                <a id="linkPuzzles" href="#puzzles">Try Puzzle</a>
            </div>
        </div>
    </div>

    <div id="puzzleContainer" class="puzzle-container hidden">
        <h2>Puzzle Hub</h2>
        <div id="puzzleStatus" class="puzzle-status sr-only">Fetching puzzle...</div>
        <div id="puzzleDetails" class="puzzle-details hidden">
            <div class="puzzle-header-row">
                <div class="puzzle-meta">
                    <div class="puzzle-field"><strong>ID:</strong><span id="puzzleId"></span></div>
                    <div class="puzzle-field"><strong>Puzzle Rating:</strong><span id="puzzleRating"></span></div>
                    <div class="puzzle-field"><strong>Popularity:</strong><span id="puzzlePopularity"></span></div>
                    <div class="puzzle-field"><strong>Streak:</strong><span id="puzzleStreak">0</span></div>
                    <div class="puzzle-field"><strong>FEN:</strong><code id="puzzleFen" class="puzzle-fen"></code></div>
                    <div class="puzzle-field puzzle-field-column">
                        <strong>Themes:</strong>
                        <div id="puzzleThemes" class="puzzle-tags"></div>
                    </div>
                    <div class="puzzle-field"><strong>Game:</strong><a id="puzzleGameLink" class="puzzle-game-link" href="#" target="_blank" rel="noopener">View on Lichess</a></div>
                </div>
                <aside class="puzzle-rating-card" aria-live="polite">
                    <h3>Your Puzzle Rating</h3>
                    <div class="puzzle-rating-value" id="playerPuzzleRating"></div>
                    <div class="puzzle-rating-delta" id="playerPuzzleDelta"></div>
                    <div class="puzzle-rating-trend-wrapper">
                        <canvas id="puzzleRatingTrend" aria-hidden="true"></canvas>
                        <div id="puzzleRatingTrendEmpty" class="puzzle-rating-trend-empty">Play a puzzle to start your rating journey.</div>
                    </div>
                    <div class="puzzle-rating-note">Rating adjusts after each attempt using an ELO-inspired formula. Keep your streak going to climb higher!</div>
                </aside>
            </div>
        </div>
        <div id="puzzleBoardWrapper" class="puzzle-board-wrapper hidden">
            <div class="puzzle-board-overlay">
                <div id="puzzleStatusFloating" class="puzzle-status-floating" role="alert" aria-live="polite">Fetching puzzle...</div>
            </div>
            <div id="puzzleSuccessModal" class="puzzle-success-modal" role="dialog" aria-modal="true" aria-labelledby="puzzleSuccessTitle" aria-describedby="puzzleSuccessBody">
                <div class="puzzle-success-content">
                    <div id="puzzleSuccessTitle" class="sr-only">Puzzle completed</div>
                    <h3>Nice work!</h3>
                    <p id="puzzleSuccessBody">You solved the puzzle. Ready for another challenge?</p>
                    <div class="puzzle-success-actions">
                        <button id="puzzlePlayAgain">New Puzzle</button>
                        <button id="puzzleStayHere">Review Position</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <div id="appContainer" class="container hidden">
        <section class="game-section">
            <div class="players-container">
                <div class="player white active" id="whitePlayer">
                    <div class="player-name">White Player</div>
                    <div class="player-status">Controlling White Pieces</div>
                </div>
                <div class="player black" id="blackPlayer">
                    <div class="player-name">Black Player</div>
                    <div class="player-status">Controlling Black Pieces</div>
                </div>
            </div>
            
            <div class="board-eval-container">
                <div class="chessboard" id="chessboard">
                    <!-- Chessboard will be generated by JavaScript -->
                </div>
                <div class="engine-eval-bar" id="engineEvalBar" aria-hidden="true">
                    <div class="engine-eval-fill" id="engineEvalFill"></div>
                    <div class="engine-eval-label" id="engineEvalLabel"></div>
                </div>
            </div>
            
            <div class="controls" id="boardControls">
                <button id="newGame">New Game</button>
                <button id="flipBoard">Flip Board</button>
                <button id="undoMove">Undo Move</button>
                <button id="redoMove">Redo Move</button>
                <button id="resign">Resign</button>
                <button id="openInAnalysis" class="hidden">Open in Analysis</button>
                <button id="openInAnalysisEngine" class="hidden">Analyze with Engine</button>
            </div>
            
            <div class="status" id="gameStatus">
                White to move
            </div>

            <div id="evaluationGraphPanel" class="evaluation-graph-panel" hidden>
                <div class="evaluation-graph-header">
                    <h2>Evaluation Graph</h2>
                    <div id="evaluationGraphLatest" class="evaluation-graph-latest">Last: </div>
                </div>
                <div class="evaluation-graph-body">
                    <canvas id="evaluationGraphCanvas"></canvas>
                    <div id="evaluationGraphEmpty" class="evaluation-graph-empty">Engine evaluation timeline will appear here once analysis begins.</div>
                </div>
            </div>

            <div class="game-history-panel" id="gameHistoryPanel" hidden>
                <h2>
                    Completed Games
                    <small id="gameHistoryMeta">
                        
                    </small>
                </h2>
                <div class="game-history-toolbar">
                    <button id="gameHistoryRefresh">Refresh</button>
                    <button id="gameHistoryClear">Clear History</button>
                </div>
                <div id="gameHistoryEmpty" class="game-history-empty">No completed games yet. Finish a game to see it here.</div>
                <div id="gameHistoryTableWrapper" class="game-history-table-wrapper" hidden>
                    <table class="game-history-table">
                        <thead>
                            <tr>
                                <th scope="col">Finished</th>
                                <th scope="col">Result</th>
                                <th scope="col">Winner</th>
                                <th scope="col">Moves</th>
                                <th scope="col">Players</th>
                                <th scope="col">Replay</th>
                            </tr>
                        </thead>
                        <tbody id="gameHistoryBody"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <section class="info-section">
            <h2>Game Information</h2>
            <p>Current player: <span id="currentPlayer">White</span></p>
            <p>Move count: <span id="moveCount">0</span></p>
            <p>Game status: <span id="statusDetail">In Progress</span></p>
            <p>Material balance: <span id="materialBalance">Equal</span></p>

            <h2>Captured</h2>
            <div class="captured-row">
                <div class="captured-label">White</div>
                <div id="capturedByWhite" class="captured-list"></div>
            </div>
            <div class="captured-row captured-row--spaced">
                <div class="captured-label">Black</div>
                <div id="capturedByBlack" class="captured-list"></div>
            </div>
            
            <h2>Move History</h2>
            <div class="move-history">
                <div class="move-list" id="moveList">
                    <!-- Move history will be populated by JavaScript -->
                </div>
            </div>

            <div class="puzzle-actions" id="puzzleControls" hidden>
                <button id="puzzleRefresh">New Puzzle</button>
                <button id="puzzleReview" disabled>Review Mistakes</button>
                <button id="puzzleHistoryBtn">View History</button>
                <button id="puzzleHint">Hint</button>
                <button id="undoMovePuzzle">Undo</button>
                <button id="redoMovePuzzle">Redo</button>
                <button id="flipBoardPuzzle">Flip Board</button>
                <button id="puzzleCopyFen">Copy FEN</button>
                <button id="puzzleLoadBoard">Open in Analysis</button>
                <button id="puzzleLoadBoardEngine">Analyze with Engine</button>
                <button id="puzzleClearHistoryKeepStreak">Reset History (Keep Streak)</button>
                <button id="puzzleClearHistory">Reset History &amp; Streak</button>
            </div>

            <div id="analysisPanel" class="analysis-panel hidden">
                <div class="analysis-header" id="analysisHeader">
                    <h2 class="analysis-title">Engine Analysis</h2>
                    <button id="analysisToggle" class="analysis-toggle">Start</button>
                </div>
                <div id="analysisStatus" class="analysis-status">Idle</div>
                <div id="analysisScore" class="analysis-score">Score: </div>
                <div id="analysisDepth" class="analysis-depth">Depth: </div>
                <div id="analysisLines" class="analysis-lines"></div>
                <div class="analysis-lines-row">
                    <input id="fenInput" type="text" placeholder="FEN" class="fen-input">
                    <div class="analysis-actions">
                        <button id="loadFENBtn">Load FEN</button>
                        <button id="copyFENBtn">Copy FEN</button>
                    </div>
                </div>
                <div class="pgn-input-group">
                    <textarea id="pgnInput" rows="4" placeholder="Paste PGN here" class="pgn-input"></textarea>
                    <div class="pgn-controls" id="pgnControls">
                        <button id="loadPGNBtn">Load PGN</button>
                        <button id="pgnStartBtn">Go to Start</button>
                        <button id="pgnPrevBtn">Prev Move</button>
                        <button id="pgnNextBtn">Next Move</button>
                        <button id="pgnEndBtn">Go to End</button>
                        <label class="pgn-speed-label">
                            <span>Replay speed (ms)</span>
                            <input id="pgnSpeed" type="number" min="200" step="100" value="800" class="pgn-speed-input">
                        </label>
                        <button id="pgnPlayBtn">Play </button>
                        <button id="pgnStop">Stop Replay</button>
                        <button id="exportPGNBtn">Export PGN</button>
                        <div id="pgnVariations" class="pgn-variations hidden"></div>
                    </div>
                </div>
                <div class="move-comment-section">
                    <h3 class="move-comment-title">Move Comment</h3>
                    <div class="move-comment-wrapper">
                        <textarea id="moveComment" rows="2" placeholder="Add a comment for the current move" class="move-comment-text"></textarea>
                        <div class="modal-actions">
                            <button id="saveCommentBtn">Save Comment</button>
                            <button id="clearMoveComment">Clear</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>
    
    <!-- Play vs Computer Modal -->
    <div id="aiOpponentModal" class="ai-modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="aiOpponentTitle">
        <div class="ai-modal">
            <h3 id="aiOpponentTitle">Choose Your Opponent</h3>
            <div class="ai-modal-section">
                <div class="ai-modal-section-header">Select AI Engine</div>
                <div id="aiOpponentList" class="ai-opponent-list" data-role="radiogroup" data-label="Available opponents">
                    <!-- Opponent cards populated via script -->
                </div>
            </div>
            <div class="ai-modal-section">
                <div class="ai-modal-section-header">Your Side</div>
                <div class="ai-side-options" role="radiogroup" aria-label="Choose your color">
                    <label><input type="radio" name="aiPlayerSide" value="white" checked> Play as White</label>
                    <label><input type="radio" name="aiPlayerSide" value="black"> Play as Black</label>
                    <label><input type="radio" name="aiPlayerSide" value="random"> Random</label>
                </div>
            </div>
            <div class="ai-modal-actions">
                <button id="aiModalCancel">Cancel</button>
                <button id="aiModalStart" class="primary">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Promotion Modal -->
    <div id="promotionBackdrop" class="modal-backdrop">
        <div class="modal">
            <h3>Choose Promotion</h3>
            <div class="promo-grid">
                <button class="promo-btn" data-piece="q" title="Queen"><span class="promo-icons">/</span>Queen</button>
                <button class="promo-btn" data-piece="r" title="Rook"><span class="promo-icons">/</span>Rook</button>
                <button class="promo-btn" data-piece="b" title="Bishop"><span class="promo-icons">/</span>Bishop</button>
                <button class="promo-btn" data-piece="n" title="Knight"><span class="promo-icons">/</span>Knight</button>
            </div>
            <div class="modal-actions">
                <button id="promotionCancel" class="promo-btn modal-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="authModalBackdrop" class="auth-modal-backdrop" aria-hidden="true">
        <div class="auth-modal" role="dialog" aria-modal="true" aria-labelledby="authModalTitle">
            <button id="authModalClose" class="auth-close" aria-label="Close authentication dialog"></button>
            <h2 id="authModalTitle">Welcome back</h2>
            <div class="auth-toggle" role="tablist">
                <button id="authTabLogin" class="active" role="tab" aria-selected="true">Sign In</button>
                <button id="authTabRegister" role="tab" aria-selected="false">Create Account</button>
            </div>
            <form id="authForm" class="auth-form">
                <div id="authFeedback" aria-live="assertive"></div>
                <label>
                    Username
                    <input id="authUsernameInput" name="username" type="text" autocomplete="username" required minlength="3" maxlength="32" />
                </label>
                <label>
                    Password
                    <input id="authPasswordInput" name="password" type="password" autocomplete="current-password" required minlength="6" maxlength="64" />
                </label>
                <div id="authConfirmGroup" hidden>
                    <label>
                        Confirm Password
                        <input id="authConfirmPasswordInput" name="confirmPassword" type="password" autocomplete="new-password" minlength="6" maxlength="64" />
                    </label>
                </div>
                <div class="form-actions">
                    <button type="submit" class="auth-button" id="authSubmitBtn">Sign In</button>
                    <button type="button" class="auth-button secondary" id="authCancelBtn">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const authState = {
                currentUser: null,
                pending: false,
                error: null,
                justCreated: false,
                token: null,
            };

            const authStatusEl = document.getElementById('authStatus');
            const authUsernameEl = document.getElementById('authUsername');
            const authLoginBtn = document.getElementById('authLoginBtn');
            const authLogoutBtn = document.getElementById('authLogoutBtn');
            const authModalBackdrop = document.getElementById('authModalBackdrop');
            const authModalCloseBtn = document.getElementById('authModalClose');
            const authTabLoginBtn = document.getElementById('authTabLogin');
            const authTabRegisterBtn = document.getElementById('authTabRegister');
            const authForm = document.getElementById('authForm');
            const authFeedbackEl = document.getElementById('authFeedback');
            const authUsernameInput = document.getElementById('authUsernameInput');
            const authPasswordInput = document.getElementById('authPasswordInput');
            const authConfirmGroup = document.getElementById('authConfirmGroup');
            const authConfirmPasswordInput = document.getElementById('authConfirmPasswordInput');
            const authSubmitBtn = document.getElementById('authSubmitBtn');
            const authCancelBtn = document.getElementById('authCancelBtn');

            let authMode = 'login';

            const STORAGE_KEY = 'chessmasterAuth';

            function persistAuthState() {
                if (authState.currentUser && authState.token) {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify({
                        user: authState.currentUser,
                        token: authState.token,
                    }));
                } else {
                    localStorage.removeItem(STORAGE_KEY);
                }
            }

            function updateRatingTrendChart() {
                const canvas = ratingTrendState.canvas;
                if (!canvas) return;
                const empty = ratingTrendState.empty;
                const history = Array.isArray(puzzleState.ratingHistory)
                    ? puzzleState.ratingHistory.slice().sort((a, b) => {
                        const aTime = Number.isFinite(a?.timestamp) ? a.timestamp : 0;
                        const bTime = Number.isFinite(b?.timestamp) ? b.timestamp : 0;
                        return aTime - bTime;
                    })
                    : [];
                if (!history.length) {
                    canvas.style.display = 'none';
                    canvas.setAttribute('aria-hidden', 'true');
                    if (empty) empty.style.display = 'block';
                    return;
                }
                if (empty) empty.style.display = 'none';
                canvas.style.display = 'block';
                canvas.setAttribute('aria-hidden', 'false');
                const rect = canvas.getBoundingClientRect();
                const width = Math.max(200, Math.round(rect.width || canvas.width || 320));
                const height = Math.max(100, Math.round(rect.height || canvas.height || 110));
                if (canvas.width !== width) canvas.width = width;
                if (canvas.height !== height) canvas.height = height;
                const ctx = ratingTrendState.ctx || canvas.getContext('2d');
                ratingTrendState.ctx = ctx;
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(17, 24, 32, 0.75)';
                ctx.fillRect(0, 0, width, height);

                const ratings = history.map((point) => point.rating);
                const minRating = Math.min(...ratings);
                const maxRating = Math.max(...ratings);
                const padding = Math.max(10, Math.round((maxRating - minRating) * 0.1));
                const rangeMin = Math.max(100, minRating - padding);
                const rangeMax = maxRating + padding;
                const firstTs = history[0].timestamp || 0;
                const lastTs = history[history.length - 1].timestamp || firstTs + 1;
                const timeSpan = Math.max(1, lastTs - firstTs);

                const mapX = (timestamp) => {
                    if (history.length === 1) return width / 2;
                    return ((timestamp - firstTs) / timeSpan) * (width - 20) + 10;
                };
                const mapY = (rating) => {
                    if (!Number.isFinite(rangeMax - rangeMin) || rangeMax === rangeMin) {
                        return height / 2;
                    }
                    return height - (((rating - rangeMin) / (rangeMax - rangeMin)) * (height - 20) + 10);
                };

                ctx.strokeStyle = '#58d68d';
                ctx.lineWidth = 2;
                ctx.beginPath();
                history.forEach((point, index) => {
                    const x = mapX(point.timestamp || firstTs);
                    const y = mapY(point.rating);
                    if (index === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                ctx.fillStyle = '#f1c40f';
                history.forEach((point) => {
                    const x = mapX(point.timestamp || firstTs);
                    const y = mapY(point.rating);
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function rebuildRatingHistoryFromAttempts() {
                const attempts = Array.isArray(gameState.attemptHistory) ? gameState.attemptHistory.slice() : [];
                attempts.sort((a, b) => {
                    const aTime = Number.isFinite(a?.completedAt) ? a.completedAt : (Number.isFinite(a?.timestamp) ? a.timestamp : 0);
                    const bTime = Number.isFinite(b?.completedAt) ? b.completedAt : (Number.isFinite(b?.timestamp) ? b.timestamp : 0);
                    return aTime - bTime;
                });
                const history = [];
                let lastRating = Number.isFinite(puzzleState.playerRating) ? Math.round(puzzleState.playerRating) : null;
                attempts.forEach((attempt) => {
                    let rating = Number.isFinite(attempt?.ratingAfter) ? Math.round(attempt.ratingAfter) : null;
                    if (!Number.isFinite(rating) && Number.isFinite(lastRating) && Number.isFinite(attempt?.delta)) {
                        rating = Math.max(100, Math.round(lastRating + attempt.delta));
                    }
                    if (!Number.isFinite(rating)) return;
                    const timestamp = Number.isFinite(attempt?.completedAt)
                        ? attempt.completedAt
                        : (Number.isFinite(attempt?.timestamp) ? attempt.timestamp : Date.now());
                    history.push({ rating, timestamp });
                    lastRating = rating;
                });
                if (!history.length && Number.isFinite(puzzleState.playerRating)) {
                    history.push({ rating: Math.round(puzzleState.playerRating), timestamp: Date.now() });
                }
                puzzleState.ratingHistory = history.slice(-500);
            }

            function restoreAuthState() {
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (!raw) return;
                    const parsed = JSON.parse(raw);
                    if (parsed && parsed.user && parsed.token) {
                        authState.currentUser = parsed.user;
                        authState.token = parsed.token;
                    }
                } catch (err) {
                    console.warn('Unable to restore auth state', err);
                }
            }

            async function authorizedFetch(url, options = {}) {
                const headers = new Headers(options.headers || {});
                headers.set('Content-Type', 'application/json');
                if (authState.token) {
                    headers.set('Authorization', `Bearer ${authState.token}`);
                }
                const response = await fetch(url, {
                    ...options,
                    headers,
                });
                if (response.status === 401 || response.status === 403) {
                    handleLogout();
                    throw new Error('Unauthorized. Please sign in again.');
                }
                return response;
            }

            async function fetchUserProfile() {
                if (!authState.currentUser) return null;
                const endpoint = `${backendBase}/users/${encodeURIComponent(authState.currentUser.id)}`;
                const res = await authorizedFetch(endpoint, { method: 'GET' });
                if (!res.ok) throw new Error('Unable to fetch profile');
                const data = await res.json();
                return data;
            }

            async function fetchUserHistory() {
                if (!authState.currentUser) return { games: [], puzzles: [] };
                const endpoint = `${backendBase}/users/${encodeURIComponent(authState.currentUser.id)}/history`;
                const res = await authorizedFetch(endpoint, { method: 'GET' });
                if (!res.ok) throw new Error('Unable to fetch history');
                return res.json();
            }

            async function appendHistoryEntry(payload) {
                if (!authState.currentUser) return;
                const endpoint = `${backendBase}/users/${encodeURIComponent(authState.currentUser.id)}/history`;
                const res = await authorizedFetch(endpoint, {
                    method: 'POST',
                    body: JSON.stringify(payload),
                });
                if (!res.ok) {
                    const text = await res.text();
                    throw new Error(text || 'Unable to persist history');
                }
            }

            function syncPuzzleAttemptWithBackend(attempt) {
                if (!authState.currentUser || !attempt || !attempt.id) return Promise.resolve();
                const attemptedAt = Number.isFinite(attempt.completedAt)
                    ? new Date(attempt.completedAt).toISOString()
                    : new Date().toISOString();
                const payload = {
                    puzzleId: attempt.id,
                    solved: !!attempt.success,
                    ratingDelta: Number.isFinite(attempt.delta) ? attempt.delta : 0,
                    streakDelta: 0,
                    attemptedAt,
                };
                const ratingAfter = Number.isFinite(attempt.ratingAfter)
                    ? Math.round(attempt.ratingAfter)
                    : (Number.isFinite(puzzleState.playerRating) ? Math.round(puzzleState.playerRating) : undefined);
                if (Number.isFinite(ratingAfter)) {
                    payload.ratingAfter = ratingAfter;
                    if (!Number.isFinite(payload.rating)) {
                        payload.rating = ratingAfter;
                    }
                }
                if (Number.isFinite(puzzleState.streak)) {
                    payload.streak = puzzleState.streak;
                }
                return appendHistoryEntry({ type: 'puzzle', payload });
            }

            async function loadUserDataIntoState() {
                try {
                    const [history, profile] = await Promise.all([
                        fetchUserHistory(),
                        fetchUserProfile(),
                    ]);
                    const games = Array.isArray(history?.games) ? history.games : [];
                    const puzzles = Array.isArray(history?.puzzles) ? history.puzzles : [];
                    if (profile) {
                        authState.currentUser = { ...(authState.currentUser || {}), ...profile };
                        persistAuthState();
                    }
                    const now = Date.now();
                    const normalizedPuzzles = puzzles
                        .map((entry) => {
                            const attemptedAt = entry?.attemptedAt ? Date.parse(entry.attemptedAt) : undefined;
                            const enriched = {
                                ...entry,
                                id: entry?.puzzleId ?? entry?.id,
                                puzzleId: entry?.puzzleId ?? entry?.id,
                                success: entry?.solved ?? entry?.success,
                                delta: entry?.ratingDelta ?? entry?.delta,
                                ratingDelta: entry?.ratingDelta ?? entry?.delta,
                                ratingAfter: entry?.ratingAfter ?? entry?.rating_after,
                                streak: entry?.streak ?? entry?.streakAfter,
                                timestamp: Number.isFinite(attemptedAt) ? attemptedAt : entry?.timestamp,
                                completedAt: Number.isFinite(attemptedAt) ? attemptedAt : entry?.completedAt,
                            };
                            return normalizeAttemptRecord(enriched, now);
                        })
                        .filter(Boolean);
                    gameState.attemptHistory = normalizedPuzzles;
                    gameState.reviewQueue = []; // backend does not yet persist review queue
                    gameState.solvedIds = new Set(
                        normalizedPuzzles
                            .filter((puzzle) => puzzle?.success)
                            .map((puzzle) => String(puzzle.puzzleId || puzzle.id))
                    );
                    puzzleState.streak = profile?.streak ?? 0;
                    puzzleState.playerRating = profile?.rating ?? 1500;
                    completedHistory.entries = games.map((entry) => ({
                        id: entry.id,
                        finishedAt: entry.finishedAt,
                        result: entry.result,
                        reason: entry.reason,
                        winner: entry.winner,
                        players: entry.players,
                        moves: entry.moves,
                    }));
                    gameState.completedHistoryLoaded = true;
                    refreshPuzzleHistoryView();
                    updatePuzzleStreakDisplay();
                    updatePlayerRatingDisplay();
                    updateReviewButtonState();
                    renderCompletedGames();
                    rebuildRatingHistoryFromAttempts();
                    updateRatingTrendChart();
                } catch (err) {
                    console.warn('Unable to load user data', err);
                    throw err;
                }
            }

            async function attemptSessionRestore() {
                if (!authState.currentUser || !authState.token) {
                    rebuildRatingHistoryFromAttempts();
                    updateRatingTrendChart();
                    return;
                }
                try {
                    await loadUserDataIntoState();
                    updateAuthUI();
                } catch (err) {
                    console.warn('Unable to restore session', err);
                    handleLogout();
                }
            }

            function recordCompletedGame({ winner = null, result = 'completed', reason = null } = {}) {
                const entry = {
                    id: gameState.currentGameId || generateGameSessionId(),
                    finishedAt: new Date().toISOString(),
                    result,
                    winner,
                    reason,
                    moves: serializeMoveHistory(),
                    players: snapshotPlayers(),
                };

                completedHistory.entries.push(entry);
                if (completedHistory.entries.length > 200) {
                    completedHistory.entries = completedHistory.entries.slice(-200);
                }
                gameState.completedHistoryLoaded = true;
                renderCompletedGames();
                if (authState.currentUser) {
                    appendHistoryEntry({
                        type: 'game',
                        payload: {
                            id: entry.id,
                            finishedAt: entry.finishedAt,
                            result: entry.result,
                            reason: entry.reason,
                            winner: entry.winner,
                            players: entry.players,
                            moves: entry.moves,
                        },
                    }).catch((err) => console.warn('Unable to persist game history', err));
                }
            }

            function resetStateToGuestDefaults() {
                gameState.attemptHistory = [];
                gameState.reviewQueue = [];
                gameState.solvedIds = new Set();
                puzzleState.streak = 0;
                puzzleState.playerRating = 1500;
                puzzleState.ratingHistory = [];
                completedHistory.entries = [];
                gameState.completedHistoryLoaded = false;
                refreshPuzzleHistoryView();
                updatePuzzleStreakDisplay();
                updatePlayerRatingDisplay();
                updateReviewButtonState();
                renderCompletedGames();
                updateRatingTrendChart();
            }

            function showAuthModal(mode = 'login') {
                authMode = mode;
                if (authMode === 'register') {
                    authTabLoginBtn.classList.remove('active');
                    authTabLoginBtn.setAttribute('aria-selected', 'false');
                    authTabRegisterBtn.classList.add('active');
                    authTabRegisterBtn.setAttribute('aria-selected', 'true');
                    authConfirmGroup.hidden = false;
                    authConfirmPasswordInput.required = true;
                    authSubmitBtn.textContent = 'Create Account';
                    authModalTitle.textContent = 'Create account';
                } else {
                    authTabRegisterBtn.classList.remove('active');
                    authTabRegisterBtn.setAttribute('aria-selected', 'false');
                    authTabLoginBtn.classList.add('active');
                    authTabLoginBtn.setAttribute('aria-selected', 'true');
                    authConfirmGroup.hidden = true;
                    authConfirmPasswordInput.required = false;
                    authSubmitBtn.textContent = 'Sign In';
                    authModalTitle.textContent = 'Welcome back';
                }
                authFeedbackEl.textContent = '';
                authFeedbackEl.className = '';
                authUsernameInput.value = '';
                authPasswordInput.value = '';
                if (authConfirmPasswordInput) authConfirmPasswordInput.value = '';
                authModalBackdrop.classList.add('visible');
                authModalBackdrop.setAttribute('aria-hidden', 'false');
                setTimeout(() => {
                    authUsernameInput.focus({ preventScroll: true });
                }, 30);
            }

            function hideAuthModal() {
                authModalBackdrop.classList.remove('visible');
                authModalBackdrop.setAttribute('aria-hidden', 'true');
            }

            function updateAuthUI() {
                if (authState.currentUser) {
                    if (authStatusEl) {
                        authStatusEl.hidden = false;
                        if (authUsernameEl) authUsernameEl.textContent = authState.currentUser.username;
                    }
                    if (authLogoutBtn) authLogoutBtn.hidden = false;
                    if (authLoginBtn) authLoginBtn.hidden = true;
                } else {
                    if (authStatusEl) authStatusEl.hidden = true;
                    if (authLogoutBtn) authLogoutBtn.hidden = true;
                    if (authLoginBtn) authLoginBtn.hidden = false;
                    if (authUsernameEl) authUsernameEl.textContent = 'Guest';
                }
            }

            async function handleLoginSubmit(event) {
                event.preventDefault();
                const username = authUsernameInput.value.trim();
                const password = authPasswordInput.value;
                const confirmPassword = authConfirmPasswordInput.value;
                if (!username || !password) {
                    authFeedbackEl.textContent = 'Username and password are required.';
                    authFeedbackEl.className = 'auth-error';
                    return;
                }
                if (authMode === 'register' && password !== confirmPassword) {
                    authFeedbackEl.textContent = 'Passwords do not match.';
                    authFeedbackEl.className = 'auth-error';
                    return;
                }
                if (authMode === 'register') {
                    try {
                        const res = await fetch(`${backendBase}/auth/signup`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ username, password, email: `${username}@example.com` }),
                        });
                        if (!res.ok) {
                            const body = await res.json().catch(() => ({}));
                            throw new Error(body.error || 'Unable to create account.');
                        }
                        const data = await res.json();
                        authState.currentUser = data.user;
                        authState.token = data.token;
                        persistAuthState();
                        authFeedbackEl.textContent = 'Account created successfully!';
                        authFeedbackEl.className = 'auth-success';
                        authState.justCreated = true;
                        await loadUserDataIntoState();
                    } catch (err) {
                        authFeedbackEl.textContent = err.message || 'Unable to create account.';
                        authFeedbackEl.className = 'auth-error';
                        return;
                    }
                } else {
                    try {
                        const res = await fetch(`${backendBase}/auth/login`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ username, password }),
                        });
                        if (!res.ok) {
                            const body = await res.json().catch(() => ({}));
                            throw new Error(body.error || 'Unable to sign in.');
                        }
                        const data = await res.json();
                        authState.currentUser = data.user;
                        authState.token = data.token;
                        persistAuthState();
                        authFeedbackEl.textContent = 'Signed in successfully!';
                        authFeedbackEl.className = 'auth-success';
                        await loadUserDataIntoState();
                    } catch (err) {
                        authFeedbackEl.textContent = err.message || 'Unable to sign in.';
                        authFeedbackEl.className = 'auth-error';
                        return;
                    }
                }
                updateAuthUI();
                setTimeout(() => {
                    hideAuthModal();
                }, 500);
            }

            function handleLogout() {
                authState.currentUser = null;
                authState.token = null;
                authState.justCreated = false;
                persistAuthState();
                resetStateToGuestDefaults();
                updateAuthUI();
            }

            if (authLoginBtn) {
                authLoginBtn.addEventListener('click', () => {
                    showAuthModal('login');
                });
            }
            if (authLogoutBtn) {
                authLogoutBtn.addEventListener('click', () => {
                    handleLogout();
                });
            }
            if (authModalCloseBtn) {
                authModalCloseBtn.addEventListener('click', () => {
                    hideAuthModal();
                });
            }
            if (authCancelBtn) {
                authCancelBtn.addEventListener('click', () => {
                    hideAuthModal();
                });
            }
            if (authTabLoginBtn) {
                authTabLoginBtn.addEventListener('click', () => {
                    showAuthModal('login');
                });
            }
            if (authTabRegisterBtn) {
                authTabRegisterBtn.addEventListener('click', () => {
                    showAuthModal('register');
                });
            }
            if (authModalBackdrop) {
                authModalBackdrop.addEventListener('click', (event) => {
                    if (event.target === authModalBackdrop) {
                        hideAuthModal();
                    }
                });
                authModalBackdrop.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        hideAuthModal();
                    }
                });
            }
            if (authForm) {
                authForm.addEventListener('submit', handleLoginSubmit);
            }

            updateAuthUI();

            const gameState = {
                board: [],
                currentPlayer: 'white',
                selectedPiece: null,
                validMoves: [],
                moveHistory: [],
                boardFlipped: false,
                gameOver: false,
                enPassantTarget: null,
                castlingRights: { wK: true, wQ: true, bK: true, bQ: true },
                pendingMove: null,
                halfmoveClock: 0,
                repetitionMap: {},
                history: [],
                redoHistory: [],
                // PGN replay
                pgnMoves: [],
                pgnIndex: 0,
                replayMode: false,
                replayPromotionChoice: null,
                executingPGN: false,
                pgnSynced: false,
                // Drag & Drop
                dragging: false,
                dragFrom: null,
                dragMoves: [],
                // Captures and last move
                capturedByWhite: [], // black pieces captured by white
                capturedByBlack: [], // white pieces captured by black
                lastMove: null,
                // Move comments
                moveComments: [],
                // Variations
                pgnVariations: {},
                activeVariationStart: -1,
                activeVariationIdx: -1,
                autoplaying: false,
                autoplayTimer: null,
                autoplayMs: 800,
                hintStage: 0,
                hintCoords: null,
                mode: 'local',
                currentOpponentId: null,
                computerSide: null,
                humanSide: 'white',
                computerDelayMs: 450,
                computerThinking: false,
                executingAI: false,
                computerTimer: null,
                // Puzzle Progression
                solvedIds: new Set(),
                attemptHistory: [],
                reviewQueue: [],
                reviewMode: false,
                reviewActiveEntry: null,
                reviewNeedsRepeat: false,
                mistakeRecordedForCurrent: false,
                currentGameId: null,
                gameStartTimestamp: null,
                completedReported: false,
                completionInFlight: false,
                completedHistoryLoaded: false,
            };
            window.gameState = gameState;

            const ONLINE_PLAYER_ID_STORAGE_KEY = 'chessmasterOnlinePlayerId';
            const ONLINE_USERNAME_STORAGE_KEY = 'chessmasterOnlineUsername';
            const backendBase = localStorage.getItem('chessmasterBackend') || 'https://chessmaster-backend-5wwa.onrender.com';

            const storedOnlinePlayerId = localStorage.getItem(ONLINE_PLAYER_ID_STORAGE_KEY) || null;
            const storedOnlineUsername = localStorage.getItem(ONLINE_USERNAME_STORAGE_KEY) || '';

            const puzzleState = {
                active: false,
                attemptRecorded: false,
                autoPlaying: false,
                backendBase: '',
                currentPuzzleId: null,
                heroColor: null,
                inFlight: false,
                lastDelta: 0,
                lastPuzzle: null,
                madeMistake: false,
                missedBeforeSuccess: false,
                mistakeMoves: [],
                playerRating: 1500,
                ratingHistory: [],
                ratingSettled: false,
                reviewActiveEntry: null,
                reviewMode: false,
                reviewNeedsRepeat: false,
                solution: [],
                startTimestamp: null,
                streak: 0,
                usedHint: false,
            };

            const onlineState = {
                socket: null,
                connecting: false,
                connected: false,
                playerId: storedOnlinePlayerId,
                username: storedOnlineUsername,
                desiredColor: 'random',
                assignedColor: null,
                gameId: null,
                turn: 'white',
                shareUrl: '',
                pendingAction: null,
                remoteApplying: false,
                awaitingAckUci: null,
                lastActivityAt: 0,
                manualDisconnect: false,
                inGame: false,
                status: 'Not connected',
                statusType: 'idle',
                reconnectTimer: null,
                heartbeatTimer: null,
                autoLeaveTimer: null,
                disconnectedAt: null,
                handshakeComplete: false,
                pendingMessages: [],
            };
            window.onlineState = onlineState;

            const whitePlayerPanel = document.getElementById('whitePlayer');
            const blackPlayerPanel = document.getElementById('blackPlayer');

            const playerPanelDefaults = {
                white: {
                    name: whitePlayerPanel?.querySelector('.player-name')?.textContent || 'White Player',
                    status: whitePlayerPanel?.querySelector('.player-status')?.textContent || 'Controlling White Pieces',
                },
                black: {
                    name: blackPlayerPanel?.querySelector('.player-name')?.textContent || 'Black Player',
                    status: blackPlayerPanel?.querySelector('.player-status')?.textContent || 'Controlling Black Pieces',
                }
            };

            function initializeBoard() {
                const chessboard = document.getElementById('chessboard');
                chessboard.innerHTML = '';
                chessboard.classList.toggle('flipped', !!gameState.boardFlipped);
                resetEvaluationGraph();
                
                // Reset captured and last move state on new game
                gameState.capturedByWhite = [];
                gameState.capturedByBlack = [];
                gameState.lastMove = null;

                if (gameState.mode === 'local' || gameState.mode === 'computer') {
                    gameState.currentGameId = generateGameSessionId();
                    gameState.gameStartTimestamp = Date.now();
                    gameState.completedReported = false;
                }
                // Reset variations / replay scaffolding
                gameState.pgnVariations = {};
                gameState.activeVariationStart = -1;
                gameState.activeVariationIdx = -1;
                gameState.pgnMoves = [];
                gameState.pgnIndex = 0;
                gameState.pgnSynced = true;
                gameState.history = [];
                gameState.redoHistory = [];
                clearVariationLines();

                const initialBoard = [
                    ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
                    ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                    ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
                ];
                
                gameState.board = JSON.parse(JSON.stringify(initialBoard));
                gameState.currentPlayer = 'white';
                gameState.moveHistory = [];
                gameState.gameOver = false;
                gameState.enPassantTarget = null;
                gameState.castlingRights = { wK: true, wQ: true, bK: true, bQ: true };
                gameState.halfmoveClock = 0;
                gameState.repetitionMap = {};
                
                for (let row = 0; row < 8; row++) {
                    const boardRow = document.createElement('div');
                    boardRow.className = 'board-row';
                    
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        const isLight = (row + col) % 2 === 0;
                        square.className = `square ${isLight ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;

                        const piece = initialBoard[row][col];
                        if (piece) {
                            const pieceElement = createPieceElement(piece);
                            square.appendChild(pieceElement);
                        }

                        const labelContainer = document.createElement('div');
                        labelContainer.className = 'square-label';
                        if (col === 0 || col === 7) {
                            const rankLabel = document.createElement('span');
                            rankLabel.className = `rank-label ${col === 0 ? 'rank-left' : ''} ${col === 7 ? 'rank-right' : ''}`.trim();
                            rankLabel.textContent = 8 - row;
                            labelContainer.appendChild(rankLabel);
                        }
                        if (row === 7 || row === 0) {
                            const fileLabel = document.createElement('span');
                            fileLabel.className = `file-label ${row === 7 ? 'file-bottom' : ''} ${row === 0 ? 'file-top' : ''}`.trim();
                            fileLabel.textContent = String.fromCharCode(97 + col);
                            labelContainer.appendChild(fileLabel);
                        }
                        if (labelContainer.children.length) {
                            square.appendChild(labelContainer);
                        }

                        square.addEventListener('click', () => handleSquareClick(row, col));
                        square.addEventListener('dragover', (e) => {
                            if (gameState.dragging) e.preventDefault();
                        });
                        square.addEventListener('drop', (e) => {
                            if (!gameState.dragging || !gameState.dragFrom) return;
                            e.preventDefault();
                            const toRow = row, toCol = col;
                            const [fromRow, fromCol] = gameState.dragFrom;
                            const allowed = gameState.dragMoves.some(mv => mv[0] === toRow && mv[1] === toCol);
                            if (allowed) {
                                movePiece(fromRow, fromCol, toRow, toCol);
                            }
                            gameState.dragging = false;
                            gameState.dragFrom = null;
                            gameState.dragMoves = [];
                            clearSelection();
                        });
                        boardRow.appendChild(square);
                    }
                    
                    chessboard.appendChild(boardRow);
                }
                
                updatePlayerIndicators();
                updateGameStatus();
                updateMoveHistory();
                updateCapturedUI();

                // record initial position for threefold repetition
                recordRepetition();
                // Update FEN field
                const fenEl = document.getElementById('fenInput');
                if (fenEl) fenEl.value = generateFEN();
                // Refresh variations UI if visible
                updateVariationUI();
                onAnalysisPositionChanged();

            }

            function isOnlinePlayersTurn() {
                if (gameState.mode !== 'online') return true;
                if (!onlineState.inGame) return false;
                const expectedColor = onlineState.assignedColor === 'white' ? 'w' : 'b';
                return onlineState.turn && onlineState.turn[0] === expectedColor;
            }

            function handleSquareClick(row, col) {
                if (gameState.gameOver) return;
                if (!isOnlinePlayersTurn()) return;
                const piece = gameState.board[row][col];
                const isComputerMode = gameState.mode === 'computer';
                const humanColor = (gameState.humanSide || 'white')[0];

                if (gameState.mode === 'online' && piece && piece[0] !== (onlineState.assignedColor === 'white' ? 'w' : 'b')) {
                    clearSelection();
                    return;
                }

                if (gameState.selectedPiece) {
                    const [selectedRow, selectedCol] = gameState.selectedPiece;
                    const isValidMove = gameState.validMoves.some(move => move[0] === row && move[1] === col);

                    if (isValidMove) {
                        movePiece(selectedRow, selectedCol, row, col);
                        clearSelection();
                        return;
                    }

                    if (piece && piece[0] === gameState.currentPlayer[0] && (!isComputerMode || piece[0] === humanColor) && isOnlinePlayersTurn()) {
                        selectPiece(row, col);
                        return;
                    }

                    clearSelection();
                    return;
                }

                if (piece && piece[0] === gameState.currentPlayer[0] && (!isComputerMode || piece[0] === humanColor)) {
                    selectPiece(row, col);
                }
            }

            function createPieceElement(pieceCode) {
                const piece = document.createElement('div');
                const color = pieceCode[0] === 'w' ? 'white' : 'black';
                
                piece.className = `piece ${color}-piece`;
                piece.textContent = getPieceSymbol(pieceCode);
                piece.draggable = true;
                piece.addEventListener('dragstart', (e) => {
                    if (gameState.gameOver) return;
                    if (!isOnlinePlayersTurn()) {
                        e.preventDefault();
                        return;
                    }
                    const parent = piece.parentElement;
                    if (!parent) return;
                    const fromRow = parseInt(parent.dataset.row, 10);
                    const fromCol = parseInt(parent.dataset.col, 10);
                    const p = gameState.board[fromRow][fromCol];
                    if (!p) {
                        e.preventDefault();
                        return;
                    }
                    if (gameState.mode === 'online') {
                        const expected = onlineState.assignedColor === 'white' ? 'w' : 'b';
                        if (p[0] !== expected || onlineState.turn !== onlineState.assignedColor) {
                            e.preventDefault();
                            return;
                        }
                    } else if (gameState.mode === 'computer') {
                        const humanColorDrag = (gameState.humanSide || 'white')[0];
                        if (p[0] !== humanColorDrag || gameState.currentPlayer[0] !== humanColorDrag) {
                            e.preventDefault();
                            return;
                        }
                    } else if (gameState.currentPlayer[0] !== p[0] || !isOnlinePlayersTurn()) {
                        e.preventDefault();
                        return;
                    }
                    gameState.dragging = true;
                    gameState.dragFrom = [fromRow, fromCol];
                    const rawMoves = calculateValidMoves(fromRow, fromCol);
                    gameState.dragMoves = rawMoves.filter(([r, c, ep]) => !leavesKingInCheck(fromRow, fromCol, r, c, ep));
                    clearSelection();
                    highlightSquare(fromRow, fromCol, 'selected');
                    gameState.dragMoves.forEach(([r, c, isEp]) => {
                        if (isEp || gameState.board[r][c]) highlightSquare(r, c, 'capture-move');
                        else highlightSquare(r, c, 'valid-move');
                    });
                    try { e.dataTransfer.setData('text/plain', `${fromRow},${fromCol}`); } catch {}
                });
                piece.addEventListener('dragend', () => {
                    gameState.dragging = false;
                    gameState.dragFrom = null;
                    gameState.dragMoves = [];
                    clearSelection();
                });
                return piece;
            }

            function getPieceSymbol(piece) {
                const symbols = {
                    wp: '',
                    wr: '',
                    wn: '',
                    wb: '',
                    wq: '',
                    wk: '',
                    bp: '',
                    br: '',
                    bn: '',
                    bb: '',
                    bq: '',
                    bk: '',
                };
                return symbols[piece] || '';
            }
            function updateMaterialUI() {
                const valMap = { p:1, n:3, b:3, r:5, q:9, k:0 };
                let whiteScore = 0;
                let blackScore = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = gameState.board[r][c];
                        if (!piece) continue;
                        const val = valMap[piece[1]] || 0;
                        if (piece[0] === 'w') whiteScore += val;
                        else blackScore += val;
                    }
                }
                const diff = whiteScore - blackScore;
                const el = document.getElementById('materialBalance');
                if (!el) return;
                if (diff > 0) el.textContent = `White +${diff}`;
                else if (diff < 0) el.textContent = `Black +${Math.abs(diff)}`;
                else el.textContent = 'Equal';
            }

            function openPromotionModal() {
                const backdrop = document.getElementById('promotionBackdrop');
                backdrop.style.display = 'flex';
            }

            function closePromotionModal() {
                const backdrop = document.getElementById('promotionBackdrop');
                backdrop.style.display = 'none';
            }

            function getOpponentDefinition(id) {
                if (!id) return null;
                return aiRegistry[id] || null;
            }

            function createOpponentCard(definition) {
                const card = document.createElement('label');
                card.className = 'ai-opponent-card';
                card.dataset.opponentId = definition.id;

                const input = document.createElement('input');
                input.type = 'radio';
                input.name = 'aiOpponentChoice';
                input.value = definition.id;

                const meta = document.createElement('div');
                meta.className = 'ai-opponent-meta';

                const title = document.createElement('div');
                title.className = 'ai-opponent-name';
                title.textContent = definition.name;

                const desc = document.createElement('div');
                desc.textContent = definition.description;
                desc.style.fontSize = '0.9rem';
                desc.style.color = '#bdc3c7';
                desc.style.marginTop = '0.25rem';

                const tags = document.createElement('div');
                tags.className = 'ai-opponent-tags';
                (definition.tags || []).forEach(tag => {
                    const span = document.createElement('span');
                    span.className = 'ai-tag';
                    span.textContent = tag;
                    tags.appendChild(span);
                });

                meta.appendChild(title);
                meta.appendChild(desc);
                if (tags.children.length) meta.appendChild(tags);

                input.addEventListener('change', () => {
                    document
                        .querySelectorAll('.ai-opponent-card')
                        .forEach(cardEl => cardEl.classList.remove('active'));
                    card.classList.add('active');
                    aiModalState.selectedOpponentId = definition.id;
                });

                card.appendChild(input);
                card.appendChild(meta);
                return card;
            }

            function populateOpponentModal() {
                const list = document.getElementById('aiOpponentList');
                if (!list) return;
                list.innerHTML = '';
                aiModalState.selectedOpponentId = null;
                aiRegistryOrder
                    .map(getOpponentDefinition)
                    .filter(def => def && def.enabled !== false)
                    .forEach(def => {
                        const card = createOpponentCard(def);
                        list.appendChild(card);
                    });
                // Default selection = first entry
                const firstCard = list.querySelector('.ai-opponent-card');
                if (firstCard) {
                    const radio = firstCard.querySelector('input[type="radio"]');
                    if (radio) {
                        radio.checked = true;
                        firstCard.classList.add('active');
                        aiModalState.selectedOpponentId = radio.value;
                    }
                }
            }

            function openOpponentModal(trigger) {
                const modal = document.getElementById('aiOpponentModal');
                if (!modal) return;
                aiModalState.lastFocused = trigger || document.activeElement;
                if (activeView === 'computer' && gameState.mode !== 'computer') {
                    aiModalState.returnHash = lastNonComputerView;
                } else {
                    aiModalState.returnHash = null;
                }
                populateOpponentModal();
                modal.style.display = 'flex';
                const firstRadio = modal.querySelector('input[name="aiOpponentChoice"]');
                if (firstRadio) firstRadio.focus({ preventScroll: true });
            }

            function closeOpponentModal() {
                const modal = document.getElementById('aiOpponentModal');
                if (!modal) return;
                modal.style.display = 'none';
                const { lastFocused } = aiModalState;
                if (lastFocused && typeof lastFocused.focus === 'function') {
                    setTimeout(() => lastFocused.focus({ preventScroll: true }), 50);
                }
            }

            function updatePlayerPanelsForMode() {
                const whiteNameEl = whitePlayerPanel?.querySelector('.player-name');
                const whiteStatusEl = whitePlayerPanel?.querySelector('.player-status');
                const blackNameEl = blackPlayerPanel?.querySelector('.player-name');
                const blackStatusEl = blackPlayerPanel?.querySelector('.player-status');
                if (!whiteNameEl || !whiteStatusEl || !blackNameEl || !blackStatusEl) return;

                if (gameState.mode === 'computer') {
                    const opponent = getOpponentDefinition(gameState.currentOpponentId);
                    const opponentName = opponent ? opponent.name : 'Computer';
                    if (gameState.humanSide === 'white') {
                        whiteNameEl.textContent = 'You';
                        whiteStatusEl.textContent = 'Human Player';
                        blackNameEl.textContent = opponentName;
                        blackStatusEl.textContent = 'Computer';
                    } else {
                        whiteNameEl.textContent = opponentName;
                        whiteStatusEl.textContent = 'Computer';
                        blackNameEl.textContent = 'You';
                        blackStatusEl.textContent = 'Human Player';
                    }
                } else {
                    whiteNameEl.textContent = playerPanelDefaults.white.name;
                    whiteStatusEl.textContent = playerPanelDefaults.white.status;
                    blackNameEl.textContent = playerPanelDefaults.black.name;
                    blackStatusEl.textContent = playerPanelDefaults.black.status;
                }
            }

            function setComputerMode(opponentId, humanColor) {
                const definition = getOpponentDefinition(opponentId);
                if (!definition) return false;
                const normalizedColor = ['white', 'black'].includes(humanColor) ? humanColor : (Math.random() < 0.5 ? 'white' : 'black');
                gameState.mode = 'computer';
                gameState.currentOpponentId = definition.id;
                gameState.humanSide = normalizedColor;
                gameState.computerSide = normalizedColor === 'white' ? 'black' : 'white';
                gameState.computerDelayMs = definition.moveDelayMs || 350;
                updatePlayerPanelsForMode();
                return true;
            }

            function exitComputerMode() {
                gameState.mode = 'local';
                gameState.currentOpponentId = null;
                gameState.computerSide = null;
                gameState.humanSide = 'white';
                gameState.computerThinking = false;
                if (gameState.computerTimer) {
                    clearTimeout(gameState.computerTimer);
                    gameState.computerTimer = null;
                }
                gameState.executingAI = false;
                gameState.computerResigned = false;
                updatePlayerPanelsForMode();
            }

            async function requestComputerMove() {
                if (gameState.mode !== 'computer') return;
                if (gameState.gameOver) return;
                if (gameState.currentPlayer !== gameState.computerSide) return;
                if (gameState.executingAI || gameState.computerThinking) return;
                const opponent = getOpponentDefinition(gameState.currentOpponentId);
                if (!opponent || typeof opponent.getMove !== 'function') return;

                gameState.computerThinking = true;
                gameState.executingAI = true;
                try {
                    const move = await opponent.getMove();
                    if (gameState.mode !== 'computer') return;
                    if (!move) {
                        console.warn('Computer move unavailable; falling back to random');
                        const fallback = opponent.fallbackId ? getOpponentDefinition(opponent.fallbackId) : null;
                        if (fallback && typeof fallback.getMove === 'function') {
                            const fbMove = await fallback.getMove();
                            if (gameState.mode === 'computer' && fbMove) await executeComputerMove(fbMove);
                        }
                    } else {
                        await executeComputerMove(move);
                    }
                } finally {
                    gameState.executingAI = false;
                    gameState.computerThinking = false;
                }
            }

            async function executeComputerMove(move) {
                if (gameState.mode !== 'computer') return;
                if (!move) return;
                const { fr, fc, tr, tc, promotion } = move;
                if (!isInBounds(fr, fc) || !isInBounds(tr, tc)) return;
                const piece = gameState.board[fr]?.[fc];
                if (!piece || piece[0] !== gameState.computerSide[0]) return;
                const legal = calculateValidMoves(fr, fc)
                    .filter(([rr, cc, ep]) => !leavesKingInCheck(fr, fc, rr, cc, ep));
                const match = legal.find(([rr, cc]) => rr === tr && cc === tc);
                if (!match) {
                    console.warn('Computer attempted illegal move', move);
                    return;
                }
                movePiece(fr, fc, tr, tc, true);
                gameState.replayPromotionChoice = null;
            }

            function applyPromotionChoice(choice) {
                if (!gameState.pendingMove) return;
                const pm = gameState.pendingMove;
                const files = 'abcdefgh';
                const moverColor = gameState.currentPlayer[0];
                const promo = (choice || 'q').toLowerCase();
                const promoPiece = moverColor + (['q','r','b','n'].includes(promo) ? promo : 'q');

                // Place promoted piece
                gameState.board[pm.toRow][pm.toCol] = promoPiece;
                // Update en passant target from pending
                gameState.enPassantTarget = pm.newEnPassantTarget;

                // Promotion is a pawn move: reset halfmove clock
                gameState.halfmoveClock = 0;

                // Castling rights updates (only captured rook affects rights here)
                if (pm.capturedPiece && pm.capturedPiece[1] === 'r') {
                    if (pm.toRow === 7 && pm.toCol === 0) gameState.castlingRights.wQ = false;
                    if (pm.toRow === 7 && pm.toCol === 7) gameState.castlingRights.wK = false;
                    if (pm.toRow === 0 && pm.toCol === 0) gameState.castlingRights.bQ = false;
                    if (pm.toRow === 0 && pm.toCol === 7) gameState.castlingRights.bK = false;
                }

                updateBoardUI();
                // Animate move after UI re-render
                animateMoveTransform(pm.fromRow, pm.fromCol, pm.toRow, pm.toCol);

                // Notation with promotion
                let moveNotation = '';
                if (pm.capturedPiece || pm.isEnPassant) {
                    moveNotation = `${files[pm.fromCol]}x${files[pm.toCol]}${8 - pm.toRow}=${promoPiece[1].toUpperCase()}`;
                } else {
                    moveNotation = `${files[pm.toCol]}${8 - pm.toRow}=${promoPiece[1].toUpperCase()}`;
                }

                // Check/mate detection after promotion
                const opponentColor = moverColor === 'w' ? 'b' : 'w';
                const oppKing = findKing(gameState.board, opponentColor);
                let isCheck = false;
                let isMate = false;
                if (oppKing) {
                    isCheck = isSquareAttacked(oppKing[0], oppKing[1], moverColor);
                    if (isCheck && !sideHasAnyLegalMove(opponentColor)) isMate = true;
                }
                if (isMate) moveNotation += '#'; else if (isCheck) moveNotation += '+';

                gameState.moveHistory.push({ player: gameState.currentPlayer, notation: moveNotation });
                updateMoveHistory();

                // Switch turn and update status
                setNextPlayerFromMover(moverColor);
                if (isMate) {
                    gameState.gameOver = true;
                    document.getElementById('gameStatus').textContent = `Game Over - ${gameState.currentPlayer === 'white' ? 'Black' : 'White'} wins!`;
                    document.getElementById('statusDetail').textContent = `Checkmate`;
                    const winnerColor = gameState.currentPlayer === 'white' ? 'black' : 'white';
                    stopAnalysisForGameOver();
                    if (analysisState.enabled) {
                        applyFinalEvaluation(winnerColor);
                    }
                } else {
                    // First record current position (post-promotion, side switched)
                    const countNow = recordRepetition();
                    // Evaluate draws
                    const drawReason = evaluateDrawConditions();
                    if (drawReason) {
                        setDraw(drawReason);
                    } else if (isCheck) {
                        document.getElementById('statusDetail').textContent = `Check`;
                        updateGameStatus();
                        gameState.completedReported = false;
                    } else {
                        document.getElementById('statusDetail').textContent = `In Progress`;
                        updateGameStatus();
                        gameState.completedReported = false;
                    }
                }

                gameState.pendingMove = null;
                closePromotionModal();

                if (!gameState.executingPGN && puzzleState.active && !puzzleState.autoPlaying) {
                    handlePuzzlePlayerMove(pm.fromRow, pm.fromCol, pm.toRow, pm.toCol, promoPiece[1]);
                }

                if (gameState.mode === 'computer' && !gameState.gameOver) {
                    if (gameState.computerTimer) {
                        clearTimeout(gameState.computerTimer);
                    }
                    if (gameState.currentPlayer === gameState.computerSide) {
                        gameState.computerTimer = setTimeout(() => {
                            gameState.computerTimer = null;
                            requestComputerMove();
                        }, gameState.computerDelayMs || 350);
                    }
                }

                // No extra record here, already recorded above
            }

            function evaluateDrawConditions() {
                if (hasInsufficientMaterial()) return 'Draw by insufficient material';
                // Fifty-move rule
                if (gameState.halfmoveClock >= 100) return 'Draw by fifty-move rule';
                // Stalemate: side to move has no legal moves and is not in check
                const color = gameState.currentPlayer[0];
                const kingPos = findKing(gameState.board, color);
                const inCheck = kingPos ? isSquareAttacked(kingPos[0], kingPos[1], color === 'w' ? 'b' : 'w') : false;
                const anyMove = sideHasAnyLegalMove(color);
                if (!inCheck && !anyMove) return 'Draw by stalemate';
                // Threefold repetition: if current position has occurred 3 times
                const currentKey = generatePositionKey();
                const count = gameState.repetitionMap[currentKey] || 0;
                if (count >= 3) return 'Draw by threefold repetition';
                return null;
            }

            function selectPiece(row, col) {
                clearSelection();
                
                gameState.selectedPiece = [row, col];
                highlightSquare(row, col, 'selected');
                
                let rawMoves = calculateValidMoves(row, col);
                // filter out illegal moves that leave own king in check
                gameState.validMoves = rawMoves.filter(([r, c, isEnPassant]) => !leavesKingInCheck(row, col, r, c, isEnPassant));
                gameState.validMoves.forEach(([r, c, isEnPassant]) => {
                    if (isEnPassant) {
                        highlightSquare(r, c, 'capture-move');
                    } else if (gameState.board[r][c]) {
                        highlightSquare(r, c, 'capture-move');
                    } else {
                        highlightSquare(r, c, 'valid-move');
                    }
                });
            }

            function calculateValidMoves(row, col) {
                const piece = gameState.board[row][col];
                if (!piece) return [];
                
                const pieceType = piece[1];
                const color = piece[0];
                const moves = [];
                
                switch(pieceType) {
                    case 'p': {
                        const direction = color === 'w' ? -1 : 1;
                        const startRow = color === 'w' ? 6 : 1;
                        
                        if (isInBounds(row + direction, col) && !gameState.board[row + direction][col]) {
                            moves.push([row + direction, col, false]);
                            if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                                moves.push([row + 2 * direction, col, false]);
                            }
                        }
                        
                        for (let dc of [-1, 1]) {
                            if (isInBounds(row + direction, col + dc) && 
                                gameState.board[row + direction][col + dc] && 
                                gameState.board[row + direction][col + dc][0] !== color) {
                                moves.push([row + direction, col + dc, false]);
                            }
                        }
                        
                        if (gameState.enPassantTarget) {
                            const [epRow, epCol] = gameState.enPassantTarget;
                            if (row + direction === epRow && Math.abs(col - epCol) === 1) {
                                moves.push([epRow, epCol, true]);
                            }
                        }
                        break;
                    }
                    case 'r': {
                        addLinearMoves(moves, row, col, [[-1, 0], [1, 0], [0, -1], [0, 1]], color);
                        break;
                    }
                    case 'n': {
                        const knightMoves = [
                            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                            [1, -2], [1, 2], [2, -1], [2, 1]
                        ];
                        knightMoves.forEach(([dr, dc]) => {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (isInBounds(newRow, newCol) && 
                                (!gameState.board[newRow][newCol] || gameState.board[newRow][newCol][0] !== color)) {
                                moves.push([newRow, newCol, false]);
                            }
                        });
                        break;
                    }
                    case 'b': {
                        addLinearMoves(moves, row, col, [[-1, -1], [-1, 1], [1, -1], [1, 1]], color);
                        break;
                    }
                    case 'q': {
                        addLinearMoves(moves, row, col, 
                            [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]], 
                            color);
                        break;
                    }
                    case 'k': {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (isInBounds(newRow, newCol) && 
                                    (!gameState.board[newRow][newCol] || gameState.board[newRow][newCol][0] !== color)) {
                                    const opponent = color === 'w' ? 'b' : 'w';
                                    if (!isSquareAttacked(newRow, newCol, opponent)) {
                                        moves.push([newRow, newCol, false]);
                                    }
                                }
                            }
                        }
                        
                        const opponent = color === 'w' ? 'b' : 'w';
                        const inCheck = isSquareAttacked(row, col, opponent);
                        if (!inCheck) {
                            const homeRow = color === 'w' ? 7 : 0;
                            const rightsK = color === 'w' ? gameState.castlingRights.wK : gameState.castlingRights.bK;
                            const rightsQ = color === 'w' ? gameState.castlingRights.wQ : gameState.castlingRights.bQ;
                            
                            if (row === homeRow && col === 4) {
                                if (rightsK && gameState.board[homeRow][5] === '' && gameState.board[homeRow][6] === '' &&
                                    gameState.board[homeRow][7] === (color + 'r') &&
                                    !isSquareAttacked(homeRow, 5, opponent) && !isSquareAttacked(homeRow, 6, opponent)) {
                                    moves.push([homeRow, 6, false]);
                                }
                                if (rightsQ && gameState.board[homeRow][1] === '' && gameState.board[homeRow][2] === '' && gameState.board[homeRow][3] === '' &&
                                    gameState.board[homeRow][0] === (color + 'r') &&
                                    !isSquareAttacked(homeRow, 3, opponent) && !isSquareAttacked(homeRow, 2, opponent)) {
                                    moves.push([homeRow, 2, false]);
                                }
                            }
                        }
                        break;
                    }
                }
                
                return moves;
            }

            function listAllLegalMoves(color = gameState.currentPlayer) {
                const colorKey = typeof color === 'string' && color.length ? color[0] : color;
                const legal = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = gameState.board[r][c];
                        if (!piece || piece[0] !== colorKey) continue;
                        const candidates = calculateValidMoves(r, c);
                        for (const [tr, tc, isEP] of candidates) {
                            if (leavesKingInCheck(r, c, tr, tc, isEP)) continue;
                            legal.push([r, c, tr, tc, isEP]);
                        }
                    }
                }
                return legal;
            }

            function addLinearMoves(moves, row, col, directions, color) {
                directions.forEach(([dr, dc]) => {
                    let newRow = row + dr;
                    let newCol = col + dc;
                    
                    while (isInBounds(newRow, newCol)) {
                        if (!gameState.board[newRow][newCol]) {
                            moves.push([newRow, newCol, false]);
                        } else {
                            if (gameState.board[newRow][newCol][0] !== color) {
                                moves.push([newRow, newCol, false]);
                            }
                            break;
                        }
                        newRow += dr;
                        newCol += dc;
                    }
                });
            }

            function isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            function isSquareAttacked(row, col, byColor) {
                return isSquareAttackedOnBoard(gameState.board, row, col, byColor);
            }

            function isSquareAttackedAfterMove(fromRow, fromCol, toRow, toCol, actingColor) {
                const temp = cloneBoard(gameState.board);
                const moving = temp[fromRow][fromCol];
                const color = moving[0];
                // En passant capture removal
                if (isEnPassantMove(fromRow, fromCol, toRow, toCol)) {
                    temp[fromRow][toCol] = '';
                }
                // Castling rook move for simulation
                if (moving[1] === 'k' && Math.abs(toCol - fromCol) === 2) {
                    if (toCol > fromCol) { // king-side
                        temp[fromRow][5] = temp[fromRow][7];
                        temp[fromRow][7] = '';
                    } else { // queen-side
                        temp[fromRow][3] = temp[fromRow][0];
                        temp[fromRow][0] = '';
                    }
                }
                temp[toRow][toCol] = moving;
                temp[fromRow][fromCol] = '';
                const kingPos = findKing(temp, color);
                if (!kingPos) return true;
                const opponent = color === 'w' ? 'b' : 'w';
                return isSquareAttackedOnBoard(temp, kingPos[0], kingPos[1], opponent);
            }

            function isSquareAttackedOnBoard(board, row, col, byColor) {
                const opponent = byColor;
                
                const pawnDir = opponent === 'w' ? -1 : 1;
                for (const dc of [-1, 1]) {
                    if (isInBounds(row - pawnDir, col + dc) && board[row - pawnDir][col + dc] === (opponent + 'p')) return true;
                }
                
                const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                for (const [dr, dc] of knightMoves) {
                    const r = row + dr, c = col + dc;
                    if (isInBounds(r,c) && board[r][c] === (opponent + 'n')) return true;
                }
                
                const kingMoves = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                for (const [dr, dc] of kingMoves) {
                    const r = row + dr, c = col + dc;
                    if (isInBounds(r,c) && board[r][c] === (opponent + 'k')) return true;
                }
                
                const linesR = [[-1,0],[1,0],[0,-1],[0,1]];
                for (const [dr, dc] of linesR) {
                    let r = row + dr, c = col + dc;
                    while (isInBounds(r,c)) {
                        if (!board[r][c]) {
                            r += dr; c += dc;
                            continue;
                        }
                        if (board[r][c][0] === opponent && (board[r][c][1] === 'r' || board[r][c][1] === 'q')) return true;
                        break;
                    }
                }
                
                const linesB = [[-1,-1],[-1,1],[1,-1],[1,1]];
                for (const [dr, dc] of linesB) {
                    let r = row + dr, c = col + dc;
                    while (isInBounds(r,c)) {
                        if (!board[r][c]) {
                            r += dr; c += dc;
                            continue;
                        }
                        if (board[r][c][0] === opponent && (board[r][c][1] === 'b' || board[r][c][1] === 'q')) return true;
                        break;
                    }
                }
                
                return false;
            }

            function findKing(board, color) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === color + 'k') return [r, c];
                    }
                }
                return null;
            }

            function leavesKingInCheck(fromRow, fromCol, toRow, toCol, isEnPassantMove) {
                const temp = cloneBoard(gameState.board);
                const moving = temp[fromRow][fromCol];
                const color = moving[0];
                // En passant capture removal
                if (isEnPassantMove && moving[1] === 'p') {
                    temp[fromRow][toCol] = '';
                }
                // Castling rook move for simulation
                if (moving[1] === 'k' && Math.abs(toCol - fromCol) === 2) {
                    if (toCol > fromCol) { // king-side
                        temp[fromRow][5] = temp[fromRow][7];
                        temp[fromRow][7] = '';
                    } else { // queen-side
                        temp[fromRow][3] = temp[fromRow][0];
                        temp[fromRow][0] = '';
                    }
                }
                temp[toRow][toCol] = moving;
                temp[fromRow][fromCol] = '';
                const kingPos = findKing(temp, color);
                if (!kingPos) return true;
                const opponent = color === 'w' ? 'b' : 'w';
                return isSquareAttackedOnBoard(temp, kingPos[0], kingPos[1], opponent);
            }

            function highlightSquare(row, col, className) {
                const squares = document.querySelectorAll('.square');
                const index = row * 8 + col;
                if (index >= 0 && index < squares.length) {
                    squares[index].classList.add(className);
                }
            }

            function removeHintHighlights() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('hint-highlight-piece', 'hint-highlight-target');
                });
                gameState.hintStage = 0;
                gameState.hintCoords = null;
            }

            function clearSelection() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'valid-move', 'capture-move', 'en-passant-move');
                });
                gameState.selectedPiece = null;
                gameState.validMoves = [];
            }

            function cloneBoard(board) {
                return board.map(r => r.slice());
            }

            function cloneObject(obj) {
                return JSON.parse(JSON.stringify(obj));
            }

            function withBoard(boardRef, fn) {
                const saved = gameState.board;
                gameState.board = boardRef;
                try { return fn(); } finally { gameState.board = saved; }
            }

            function pushHistory({ preserveRedo = false } = {}) {
                const snapshot = {
                    board: cloneBoard(gameState.board),
                    currentPlayer: gameState.currentPlayer,
                    castlingRights: { ...gameState.castlingRights },
                    enPassantTarget: gameState.enPassantTarget ? [...gameState.enPassantTarget] : null,
                    moveHistory: gameState.moveHistory.slice(),
                    halfmoveClock: gameState.halfmoveClock,
                    repetitionMap: { ...gameState.repetitionMap },
                    gameOver: gameState.gameOver,
                    pendingMoveOpen: !!gameState.pendingMove,
                    capturedByWhite: gameState.capturedByWhite.slice(),
                    capturedByBlack: gameState.capturedByBlack.slice(),
                    lastMove: gameState.lastMove ? { ...gameState.lastMove } : null
                };
                gameState.history.push(snapshot);
                // New move invalidates redo chain
                if (!preserveRedo) {
                    gameState.redoHistory = [];
                }
            }

            function applySnapshot(snap) {
                gameState.board = snap.board.map(r => r.slice());
                gameState.currentPlayer = snap.currentPlayer;
                gameState.castlingRights = { ...snap.castlingRights };
                gameState.enPassantTarget = snap.enPassantTarget ? [...snap.enPassantTarget] : null;
                gameState.moveHistory = snap.moveHistory.slice();
                gameState.halfmoveClock = snap.halfmoveClock;
                gameState.repetitionMap = { ...snap.repetitionMap };
                gameState.gameOver = snap.gameOver;
                gameState.pendingMove = null; // clear any modal
                gameState.capturedByWhite = snap.capturedByWhite ? snap.capturedByWhite.slice() : [];
                gameState.capturedByBlack = snap.capturedByBlack ? snap.capturedByBlack.slice() : [];
                gameState.lastMove = snap.lastMove ? { ...snap.lastMove } : null;
                closePromotionModal();
                clearSelection();
                updateBoardUI();
                updateMoveHistory();
                updatePlayerIndicators();
                updateCapturedUI();
                if (gameState.gameOver) {
                    document.getElementById('gameStatus').textContent = `Game Over - ${gameState.currentPlayer === 'white' ? 'Black' : 'White'} wins!`;
                } else {
                    const color = gameState.currentPlayer[0];
                    const opp = color === 'w' ? 'b' : 'w';
                    const k = findKing(gameState.board, color);
                    const inCheck = k ? isSquareAttacked(k[0], k[1], opp) : false;
                    document.getElementById('statusDetail').textContent = inCheck ? 'Check' : 'In Progress';
                    updateGameStatus();
                }
                onAnalysisPositionChanged();
            }

            function snapshotCurrent() {
                return {
                    board: cloneBoard(gameState.board),
                    currentPlayer: gameState.currentPlayer,
                    castlingRights: { ...gameState.castlingRights },
                    enPassantTarget: gameState.enPassantTarget ? [...gameState.enPassantTarget] : null,
                    moveHistory: gameState.moveHistory.slice(),
                    halfmoveClock: gameState.halfmoveClock,
                    repetitionMap: { ...gameState.repetitionMap },
                    gameOver: gameState.gameOver,
                    pendingMoveOpen: !!gameState.pendingMove,
                    capturedByWhite: gameState.capturedByWhite.slice(),
                    capturedByBlack: gameState.capturedByBlack.slice(),
                    lastMove: gameState.lastMove ? { ...gameState.lastMove } : null
                };
            }

            function restoreHistory() {
                if (gameState.history.length === 0) return false;
                const snap = gameState.history.pop();
                // Push current state to redo stack
                gameState.redoHistory.push(snapshotCurrent());
                applySnapshot(snap);
                return true;
            }

            function handlePuzzlePlayerMove(fr, fc, tr, tc, promotionLetter) {
                if (!puzzleState.active || puzzleState.autoPlaying || gameState.executingPGN) return;
                if (!gameState.puzzleSolution || !gameState.puzzleSolution.length) {
                    showPuzzleSuccess();
                    return;
                }
                const expected = gameState.puzzleSolution[0];
                const actual = moveToUci(fr, fc, tr, tc, promotionLetter);
                if (actual === expected) {
                    gameState.mistakeRecordedForCurrent = false;
                    gameState.puzzleSolution.shift();
                    removeHintHighlights();
                    if (!gameState.puzzleSolution.length) {
                        showPuzzleSuccess();
                        return;
                    }
                    setPuzzleStatus('Nice! Keep going');
                    // Auto-play opponent reply if present
                    if (gameState.puzzleSolution.length) {
                        playPuzzleLeadMove();
                        if (gameState.puzzleSolution.length) {
                            setPuzzleStatus('Great! Your move again');
                        }
                    }
                } else {
                    puzzleState.madeMistake = true;
                    if (expected) {
                        puzzleState.mistakeMoves.push({ expected, actual });
                        puzzleState.missedBeforeSuccess = true;
                    }
                    gameState.mistakeRecordedForCurrent = true;
                    let deltaFragment = '';
                    const currentId = String(puzzleState.currentPuzzleId || '');
                    const wasSolvedBefore = gameState.solvedIds.has(currentId);
                    if (!puzzleState.reviewMode && !wasSolvedBefore) {
                        const delta = settlePuzzleRating(0);
                        deltaFragment = puzzleState.ratingSettled ? ` ( ${formatRatingDelta(delta)} ELO)` : '';
                    } else {
                        puzzleState.ratingSettled = true;
                        puzzleState.lastDelta = 0;
                    }
                    setPuzzleStatus(`Incorrect  try again${deltaFragment}`, true);
                    if (!puzzleState.reviewMode && puzzleState.streak !== 0) {
                        puzzleState.streak = 0;
                        updatePuzzleStreakDisplay();
                    }
                    // revert move so user can retry
                    undoMove();
                    removeHintHighlights();
                }
            }

            function movePiece(fromRow, fromCol, toRow, toCol, options) {
                const opts = options || {};
                const preserveRedo = opts.preserveRedo === true;

                if (!onlineState.remoteApplying && gameState.mode === 'online') {
                    const expected = onlineState.assignedColor === 'white' ? 'w' : 'b';
                    const pieceAtSource = gameState.board[fromRow][fromCol];
                    if (!pieceAtSource || pieceAtSource[0] !== expected) {
                        return;
                    }
                    if (onlineState.turn !== onlineState.assignedColor) {
                        return;
                    }
                }

                // Capture future tail (for variations) BEFORE altering history
                const branchStartPlyPre = gameState.moveHistory.length; // ply index before this move
                let futureTailSANPre = [];
                if (gameState.redoHistory && gameState.redoHistory.length) {
                    let maxSnapIndex = 0;
                    for (let idx = 1; idx < gameState.redoHistory.length; idx++) {
                        const snap = gameState.redoHistory[idx];
                        const maxSnap = gameState.redoHistory[maxSnapIndex];
                        if ((snap.moveHistory ? snap.moveHistory.length : 0) > (maxSnap.moveHistory ? maxSnap.moveHistory.length : 0)) {
                            maxSnapIndex = idx;
                        }
                    }
                    const maxSnap = gameState.redoHistory[maxSnapIndex];
                    const full = (maxSnap.moveHistory || []).map(m => m.notation);
                    futureTailSANPre = full.slice(branchStartPlyPre);
                }
                // Save snapshot before making any changes
                pushHistory({ preserveRedo });
                const preBoard = cloneBoard(gameState.board);
                const piece = gameState.board[fromRow][fromCol];
                const capturedPiece = gameState.board[toRow][toCol];
                let isEnPassant = false;
                let enPassantNotation = '';
                let isCastling = false;
                let castlingSide = '';
                let isPromotion = false;
                let promotionPiece = '';
                
                if (piece[1] === 'p' && gameState.enPassantTarget) {
                    const [epRow, epCol] = gameState.enPassantTarget;
                    if (toRow === epRow && toCol === epCol) {
                        isEnPassant = true;
                        const capturedPawnRow = fromRow;
                        gameState.board[capturedPawnRow][toCol] = '';
                        enPassantNotation = ' e.p.';
                    }
                }
                
                if (piece[1] === 'k' && Math.abs(toCol - fromCol) === 2) {
                    isCastling = true;
                    if (toCol > fromCol) {
                        gameState.board[fromRow][5] = gameState.board[fromRow][7];
                        gameState.board[fromRow][7] = '';
                        castlingSide = 'king';
                    } else {
                        gameState.board[fromRow][3] = gameState.board[fromRow][0];
                        gameState.board[fromRow][0] = '';
                        castlingSide = 'queen';
                    }
                }
                
                let newEnPassantTarget = null;
                if (piece[1] === 'p' && Math.abs(fromRow - toRow) === 2) {
                    const direction = piece[0] === 'w' ? -1 : 1;
                    newEnPassantTarget = [fromRow + direction, toCol];
                }
                
                if (capturedPiece && capturedPiece[1] === 'k' && !isEnPassant) {
                    gameState.gameOver = true;
                    document.getElementById('statusDetail').textContent = `${gameState.currentPlayer} wins by checkmate!`;
                }
                
                gameState.board[toRow][toCol] = piece;
                gameState.board[fromRow][fromCol] = '';

                // Check if this move results in a promotion. If so, handle replay choice or open modal.
                if (piece[1] === 'p') {
                    const color = piece[0];
                    const promoteRow = color === 'w' ? 0 : 7;
                    if (toRow === promoteRow) {
                        isPromotion = true;
                        if (gameState.replayMode && gameState.replayPromotionChoice) {
                            // Auto-apply promotion for replay
                            const choice = gameState.replayPromotionChoice.toLowerCase();
                            const promoPiece = color + (['q','r','b','n'].includes(choice) ? choice : 'q');
                            gameState.board[toRow][toCol] = promoPiece;
                            gameState.replayPromotionChoice = null;
                        } else {
                            // Store pending move context and show modal; do not finalize or switch turn yet.
                            gameState.pendingMove = {
                                fromRow, fromCol, toRow, toCol, piece, capturedPiece,
                                isEnPassant, enPassantNotation, isCastling, castlingSide,
                                newEnPassantTarget
                            };
                            openPromotionModal();
                            return; // Wait for user selection
                        }
                    }
                }

                gameState.enPassantTarget = newEnPassantTarget;

                // Track captures for UI
                if (capturedPiece) {
                    if (capturedPiece[0] === 'w') gameState.capturedByBlack.push(capturedPiece);
                    else gameState.capturedByWhite.push(capturedPiece);
                }
                if (isEnPassant) {
                    // captured pawn was removed earlier
                    const cap = piece[0] === 'w' ? 'bp' : 'wp';
                    if (cap[0] === 'w') gameState.capturedByBlack.push(cap); else gameState.capturedByWhite.push(cap);
                }

                // Update halfmove clock (reset on pawn move or any capture)
                if (piece[1] === 'p' || capturedPiece || isEnPassant) {
                    gameState.halfmoveClock = 0;
                } else {
                    gameState.halfmoveClock += 1;
                }
                
                if (piece[1] === 'k') {
                    if (piece[0] === 'w') { gameState.castlingRights.wK = false; gameState.castlingRights.wQ = false; }
                    else { gameState.castlingRights.bK = false; gameState.castlingRights.bQ = false; }
                }
                if (piece[1] === 'r') {
                    if (piece[0] === 'w' && fromRow === 7 && fromCol === 0) gameState.castlingRights.wQ = false;
                    if (piece[0] === 'w' && fromRow === 7 && fromCol === 7) gameState.castlingRights.wK = false;
                    if (piece[0] === 'b' && fromRow === 0 && fromCol === 0) gameState.castlingRights.bQ = false;
                    if (piece[0] === 'b' && fromRow === 0 && fromCol === 7) gameState.castlingRights.bK = false;
                }
                if (capturedPiece && capturedPiece[1] === 'r') {
                    if (toRow === 7 && toCol === 0) gameState.castlingRights.wQ = false;
                    if (toRow === 7 && toCol === 7) gameState.castlingRights.wK = false;
                    if (toRow === 0 && toCol === 0) gameState.castlingRights.bQ = false;
                    if (toRow === 0 && toCol === 7) gameState.castlingRights.bK = false;
                }
                
                updateBoardUI();
                
                let moveNotation = '';
                if (isCastling) {
                    moveNotation = castlingSide === 'king' ? 'O-O' : 'O-O-O';
                } else if (isEnPassant) {
                    const files = 'abcdefgh';
                    moveNotation = `${files[fromCol]}x${files[toCol]}${8 - toRow}`;
                } else {
                    moveNotation = getMoveNotation(fromRow, fromCol, toRow, toCol, capturedPiece, preBoard) + enPassantNotation;
                }

                // If a manual move occurs during analysis (not triggered by PGN executor), mark PGN as desynced
                if (gameState.replayMode && !gameState.executingPGN) {
                    gameState.pgnSynced = false;
                }

                // check/checkmate detection after applying the move
                const moverColor = gameState.currentPlayer[0];
                const opponentColor = moverColor === 'w' ? 'b' : 'w';
                const oppKing = findKing(gameState.board, opponentColor);
                let isCheck = false;
                let isMate = false;
                if (oppKing) {
                    isCheck = isSquareAttacked(oppKing[0], oppKing[1], moverColor);
                    if (isCheck && !sideHasAnyLegalMove(opponentColor)) isMate = true;
                }
                if (isMate) moveNotation += '#'; else if (isCheck) moveNotation += '+';
                // store last move for highlighting
                gameState.lastMove = { fromRow, fromCol, toRow, toCol };
                gameState.moveHistory.push({
                    player: gameState.currentPlayer,
                    notation: moveNotation
                });
                updateMoveHistory();
                updateCapturedUI();

                // If in analysis and this was a manual move, record as a variation and sync PGN to follow it
                if (!gameState.executingPGN) {
                    const tools = document.getElementById('fenPgnTools');
                    const inAnalysis = tools && tools.style.display !== 'none';
                    if (inAnalysis) {
                        ensureVariationStructures();
                        gameState.replayMode = true;
                        gameState.pgnSynced = true;
                        gameState.pgnMoves = gameState.moveHistory.map(m => m.notation);
                        gameState.pgnIndex = gameState.pgnMoves.length;

                        ensureVariationStructures();
                        ensureActiveLineRegistered();
                        if (futureTailSANPre.length) {
                            const originalLine = gameState.pgnMoves.slice(0, branchStartPlyPre).concat(futureTailSANPre);
                            registerVariationLine(originalLine, branchStartPlyPre);
                        }

                        const existingId = gameState.activeLineId || null;
                        const currentLineId = upsertVariationLine({
                            moves: gameState.pgnMoves.slice(),
                            startPly: Math.min(branchStartPlyPre, gameState.pgnMoves.length),
                            existingId,
                        });
                        if (currentLineId) gameState.activeLineId = currentLineId;
                        updateVariationUI();
                    }
                }
                
                setNextPlayerFromMover(moverColor);
                if (gameState.mode === 'online' && !onlineState.remoteApplying) {
                    console.log('[online] local move committed', {
                        assigned: onlineState.assignedColor,
                        turnBefore: moverColor,
                        turnAfter: onlineState.turn,
                        awaitingAckUci: onlineState.awaitingAckUci,
                    });
                }
                // Update game status text
                if (isMate) {
                    gameState.gameOver = true;
                    document.getElementById('gameStatus').textContent = `Game Over - ${gameState.currentPlayer === 'white' ? 'Black' : 'White'} wins!`;
                    document.getElementById('statusDetail').textContent = `Checkmate`;
                    const winnerColor = gameState.currentPlayer === 'white' ? 'black' : 'white';
                    stopAnalysisForGameOver();
                    if (analysisState.enabled) {
                        applyFinalEvaluation(winnerColor);
                    }
                    recordCompletedGame({
                        winner: winnerColor === 'white' ? 'White' : 'Black',
                        result: winnerColor === 'white' ? '1-0' : '0-1',
                        reason: 'Checkmate',
                    });
                    scheduleGameCompletionReport({
                        result: 'checkmate',
                        winner: gameState.currentPlayer === 'white' ? 'Black' : 'White',
                        reason: 'Checkmate',
                    });
                } else {
                    // First record current position (post-move, side switched)
                    const countNow = recordRepetition();
                    // Evaluate draws
                    const drawReason = evaluateDrawConditions();
                    if (drawReason) {
                        setDraw(drawReason);
                    } else if (isCheck) {
                        document.getElementById('statusDetail').textContent = `Check`;
                        updateGameStatus();
                    } else {
                        document.getElementById('statusDetail').textContent = `In Progress`;
                        updateGameStatus();
                    }
                }

                if (!gameState.executingPGN && puzzleState.active && !puzzleState.autoPlaying) {
                    const promoLetter = isPromotion ? (gameState.board[toRow][toCol] ? gameState.board[toRow][toCol][1] : null) : null;
                    handlePuzzlePlayerMove(fromRow, fromCol, toRow, toCol, promoLetter);
                }

                if (gameState.mode === 'computer' && !gameState.gameOver) {
                    if (gameState.computerTimer) {
                        clearTimeout(gameState.computerTimer);
                    }
                    if (gameState.currentPlayer === gameState.computerSide) {
                        gameState.computerTimer = setTimeout(() => {
                            gameState.computerTimer = null;
                            requestComputerMove();
                        }, gameState.computerDelayMs || 350);
                    }
                }

                onAnalysisPositionChanged();

                // No extra record here, already recorded above
            }

            function sideHasAnyLegalMove(color) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = gameState.board[r][c];
                        if (piece && piece[0] === color) {
                            const moves = calculateValidMoves(r,c);
                            for (const mv of moves) {
                                if (!leavesKingInCheck(r,c, mv[0], mv[1], mv[2])) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            function getDisambiguation(pieceType, color, fromRow, fromCol, toRow, toCol, boardRef) {
                // Only applicable to pieces other than pawns
                if (pieceType === 'p') return '';
                const files = 'abcdefgh';
                const candidates = [];
                withBoard(boardRef, () => {
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            if (r === fromRow && c === fromCol) continue;
                            if (boardRef[r][c] === color + pieceType) {
                                const raw = calculateValidMoves(r, c);
                                const legal = raw.filter(([rr, cc, ep]) => !leavesKingInCheck(r, c, rr, cc, ep));
                                if (legal.some(([rr, cc]) => rr === toRow && cc === toCol)) {
                                    candidates.push({ r, c });
                                }
                            }
                        }
                    }
                });
                if (candidates.length === 0) return '';
                const sameFile = candidates.some(pos => pos.c === fromCol);
                const sameRank = candidates.some(pos => pos.r === fromRow);
                if (!sameFile) return files[fromCol];
                if (!sameRank) return String(8 - fromRow);
                return files[fromCol] + String(8 - fromRow);
            }

            function getMoveNotation(fromRow, fromCol, toRow, toCol, capturedPiece, boardRef = gameState.board) {
                const piece = boardRef[fromRow][fromCol] ? boardRef[fromRow][fromCol] : gameState.board[toRow][toCol];
                const pieceType = piece[1];
                const files = 'abcdefgh';
                const color = piece[0];

                let notation = '';

                if (pieceType !== 'p') {
                    notation += pieceType.toUpperCase();
                    // Add SAN disambiguation if needed
                    notation += getDisambiguation(pieceType, color, fromRow, fromCol, toRow, toCol, boardRef);
                }

                if (capturedPiece) {
                    if (pieceType === 'p') {
                        notation += files[fromCol];
                    }
                    notation += 'x';
                }

                notation += files[toCol] + (8 - toRow);

                return notation;
            }

            function updateBoardUI() {
                const squares = document.querySelectorAll('.square');
                
                squares.forEach(square => {
                    const piece = square.querySelector('.piece');
                    if (piece) {
                        piece.remove();
                    }
                    
                    const row = parseInt(square.dataset.row, 10);
                    const col = parseInt(square.dataset.col, 10);
                    const pieceCode = gameState.board[row][col];
                    if (pieceCode) {
                        square.appendChild(createPieceElement(pieceCode));
                    }
                    // clear previous last-move classes
                    square.classList.remove('last-from', 'last-to');
                    if (gameState.lastMove) {
                        if (gameState.lastMove.fromRow === row && gameState.lastMove.fromCol === col) {
                            square.classList.add('last-from');
                        }
                        if (gameState.lastMove.toRow === row && gameState.lastMove.toCol === col) {
                            square.classList.add('last-to');
                        }
                    }
                });
                updateMaterialUI();
            }

            function updateCapturedUI() {
                const mapSymbol = {
                    'wp': '','wr': '','wn': '','wb': '','wq': '','wk': '',
                    'bp': '','br': '','bn': '','bb': '','bq': '','bk': ''
                };
                const orderMap = { 'p': 0, 'n': 1, 'b': 2, 'r': 3, 'q': 4, 'k': 5 };
                const sortCaptured = (arr) => arr.slice().sort((a, b) => {
                    const oa = orderMap[a[1]] ?? 99;
                    const ob = orderMap[b[1]] ?? 99;
                    if (oa !== ob) return oa - ob;
                    return mapSymbol[a].localeCompare(mapSymbol[b]);
                });
                const w = document.getElementById('capturedByWhite');
                const b = document.getElementById('capturedByBlack');
                if (w) {
                    w.innerHTML = '';
                    sortCaptured(gameState.capturedByWhite).forEach(p => {
                        const s = document.createElement('span');
                        s.textContent = mapSymbol[p];
                        s.className = `captured-symbol ${p[0] === 'w' ? 'white' : 'black'}`;
                        w.appendChild(s);
                    });
                }
                if (b) {
                    b.innerHTML = '';
                    sortCaptured(gameState.capturedByBlack).forEach(p => {
                        const s = document.createElement('span');
                        s.textContent = mapSymbol[p];
                        s.className = `captured-symbol ${p[0] === 'w' ? 'white' : 'black'}`;
                        b.appendChild(s);
                    });
                }
            }

            function animateMoveTransform(fromRow, fromCol, toRow, toCol) {
                const files = document.querySelectorAll('.square');
                const fromSq = Array.from(files).find(el => parseInt(el.dataset.row,10)===fromRow && parseInt(el.dataset.col,10)===fromCol);
                const toSq = Array.from(files).find(el => parseInt(el.dataset.row,10)===toRow && parseInt(el.dataset.col,10)===toCol);
                if (!fromSq || !toSq) return;
                const toPiece = toSq.querySelector('.piece');
                if (!toPiece) return;
                const fromRect = fromSq.getBoundingClientRect();
                const toRect = toSq.getBoundingClientRect();
                const dx = fromRect.left - toRect.left;
                const dy = fromRect.top - toRect.top;
                toPiece.classList.add('animate-piece');
                toPiece.style.transform = `translate(${dx}px, ${dy}px)`;
                // trigger reflow then animate to identity
                toPiece.getBoundingClientRect();
                requestAnimationFrame(()=>{ toPiece.style.transform = 'translate(0,0)'; });
                // remove class after transition
                setTimeout(()=>{ toPiece.classList.remove('animate-piece'); toPiece.style.transform=''; }, 220);
            }

            function updatePlayerIndicators() {
                const whitePlayer = document.getElementById('whitePlayer');
                const blackPlayer = document.getElementById('blackPlayer');
                
                if (gameState.currentPlayer === 'white') {
                    whitePlayer.classList.add('active');
                    blackPlayer.classList.remove('active');
                } else {
                    blackPlayer.classList.add('active');
                    whitePlayer.classList.remove('active');
                }
                
                document.getElementById('currentPlayer').textContent = 
                    gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1);
            }

            function updateMoveHistory() {
                const moveList = document.getElementById('moveList');
                moveList.innerHTML = '';
                const makeLine = (sanArray, startAtPly, onClick) => {
                    const container = document.createElement('div');
                    container.style.display = 'flex';
                    container.style.flexDirection = 'column';
                    const line = document.createElement('div');
                    line.className = 'move';
                    line.style.fontSize = '0.9em';
                    line.style.color = '#bdc3c7';
                    const parts = [];
                    for (let i = 0; i < sanArray.length; i += 2) {
                        const num = Math.floor((startAtPly + i) / 2) + 1;
                        const whiteMove = sanArray[i] || '';
                        const blackMove = sanArray[i+1] || '';
                        if (blackMove) parts.push(`${num}. ${whiteMove} ${blackMove}`);
                        else parts.push(`${num}. ${whiteMove}`);
                    }
                    line.textContent = parts.join(' ');
                    if (onClick) {
                        line.style.cursor = 'pointer';
                        line.addEventListener('click', onClick);
                    }
                    container.appendChild(line);
                    return container;
                };
                const fullSAN = getFullMainlineSAN();
                // Render grouped by move number (white+black on the same row)
                for (let ply = 0; ply < fullSAN.length; ply += 2) {
                    const n = Math.floor(ply / 2) + 1;
                    const white = fullSAN[ply] || '';
                    const black = fullSAN[ply + 1] || '';
                    const row = document.createElement('div');
                    row.className = 'move';
                    row.textContent = black ? `${n}. ${white} ${black}` : `${n}. ${white}`;
                    moveList.appendChild(row);
                }
                document.getElementById('moveCount').textContent = fullSAN.length;
                moveList.parentElement.scrollTop = moveList.parentElement.scrollHeight;
                const fenEl = document.getElementById('fenInput');
                if (fenEl) fenEl.value = generateFEN();
            }

            function getFullMainlineSAN() {
                return gameState.moveHistory.map(m => m.notation + (m.comment ? ` {${m.comment}}` : ''));
            }

            function updateGameStatus() {
                if (gameState.gameOver) {
                    document.getElementById('gameStatus').textContent = `Game Over - ${gameState.currentPlayer === 'white' ? 'Black' : 'White'} wins!`;
                } else {
                    document.getElementById('gameStatus').textContent = 
                        `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)} to move`;
                }
            }

            function generateGameSessionId() {
                return `local-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
            }

            function determinePlayerRole(side) {
                if (gameState.mode === 'computer') {
                    return gameState.humanSide === side ? 'human' : 'computer';
                }
                return 'human';
            }

            function snapshotPlayers() {
                const whiteName = whitePlayerPanel?.querySelector('.player-name')?.textContent?.trim()
                    || playerPanelDefaults.white.name
                    || 'White Player';
                const blackName = blackPlayerPanel?.querySelector('.player-name')?.textContent?.trim()
                    || playerPanelDefaults.black.name
                    || 'Black Player';
                return [
                    {
                        id: 'white',
                        side: 'white',
                        name: whiteName,
                        role: determinePlayerRole('white'),
                    },
                    {
                        id: 'black',
                        side: 'black',
                        name: blackName,
                        role: determinePlayerRole('black'),
                    },
                ];
            }

            function serializeMoveHistory() {
                if (!Array.isArray(gameState.moveHistory)) return [];
                return gameState.moveHistory.map((entry, index) => ({
                    ply: index,
                    moveNumber: Math.floor(index / 2) + 1,
                    player: entry?.player || (index % 2 === 0 ? 'white' : 'black'),
                    notation: entry?.notation || null,
                    comment: entry?.comment || null,
                }));
            }

            function scheduleGameCompletionReport({ result, winner = null, reason = null } = {}) {
                if (puzzleState?.currentPuzzleId) return;
                if (!backendBase || typeof backendBase !== 'string') return;
                if (!gameState.mode || (gameState.mode !== 'local' && gameState.mode !== 'computer')) return;
                if (gameState.completedReported || gameState.completionInFlight) return;

                const id = gameState.currentGameId || generateGameSessionId();
                const payload = {
                    id,
                    result: result || 'completed',
                    winner,
                    reason,
                    moves: serializeMoveHistory(),
                    metadata: {
                        mode: gameState.mode,
                        startedAt: gameState.gameStartTimestamp ? new Date(gameState.gameStartTimestamp).toISOString() : null,
                        finishedAt: new Date().toISOString(),
                    },
                };
                const players = snapshotPlayers();
                if (players.length) payload.players = players;

                const endpoint = `${backendBase.replace(/\/$/, '')}/games/completed`;

                gameState.completionInFlight = true;

                fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                })
                    .then((res) => {
                        if (!res.ok) {
                            throw new Error(`Failed to record game (${res.status})`);
                        }
                        return res.json().catch(() => null);
                    })
                    .then(() => {
                        gameState.completedReported = true;
                        fetchCompletedGames();
                    })
                    .catch((err) => {
                        console.warn('Unable to record completed game', err);
                    })
                    .finally(() => {
                        gameState.completionInFlight = false;
                    });
            }

            // Set next player strictly based on mover's color
            function setNextPlayerFromMover(moverColorChar) {
                gameState.currentPlayer = (moverColorChar === 'w') ? 'black' : 'white';
                updatePlayerIndicators();
                updateGameStatus();
            }

            function setDraw(reason) {
                gameState.gameOver = true;
                document.getElementById('gameStatus').textContent = 'Game Over - Draw';
                document.getElementById('statusDetail').textContent = reason;
                recordCompletedGame({ result: 'draw', winner: null, reason });
                scheduleGameCompletionReport({ result: 'draw', reason });
            }

            function getCastlingKey() {
                const cr = gameState.castlingRights;
                return `${cr.wK?'K':''}${cr.wQ?'Q':''}${cr.bK?'k':''}${cr.bQ?'q':''}` || '-';
            }

            function getEnPassantKey() {
                if (!gameState.enPassantTarget) return '-';
                const files = 'abcdefgh';
                const [r,c] = gameState.enPassantTarget;
                return `${files[c]}${8 - r}`;
            }

            function generatePositionKey() {
                // board + side + castling + ep
                const boardKey = gameState.board.map(row => row.map(p=>p||'__').join(',')).join('|');
                const side = gameState.currentPlayer[0];
                const castle = getCastlingKey();
                const ep = getEnPassantKey();
                return `${boardKey} ${side} ${castle} ${ep}`;
            }

            function recordRepetition() {
                const key = generatePositionKey();
                gameState.repetitionMap[key] = (gameState.repetitionMap[key] || 0) + 1;
                return gameState.repetitionMap[key];
            }

            function hasInsufficientMaterial() {
                // returns true if draw by insufficient material
                const pieces = [];
                for (let r=0;r<8;r++) {
                    for (let c=0;c<8;c++) {
                        const p = gameState.board[r][c];
                        if (p) pieces.push({p, r, c});
                    }
                }
                // any pawn, rook, queen -> not insufficient
                if (pieces.some(x => x.p[1] === 'p' || x.p[1] === 'r' || x.p[1] === 'q')) return false;
                // only kings
                if (pieces.every(x => x.p[1] === 'k')) return true;
                // king + single minor
                if (pieces.filter(x => x.p[1] !== 'k').length === 1) return true;
                // bishops only and same-colored squares
                const bishops = pieces.filter(x => x.p[1] === 'b');
                const knights = pieces.filter(x => x.p[1] === 'n');
                if (knights.length === 0 && bishops.length >= 1 && pieces.every(x => x.p[1] === 'k' || x.p[1] === 'b')) {
                    const colorOfSquare = ({r,c}) => (r + c) % 2; // 0 light, 1 dark
                    const colors = bishops.map(b => colorOfSquare(b));
                    const allSame = colors.every(v => v === colors[0]);
                    if (allSame) return true;
                }
                return false;
            }

            function flipBoard() {
                gameState.boardFlipped = !gameState.boardFlipped;
                const chessboard = document.getElementById('chessboard');
                chessboard.classList.toggle('flipped', !!gameState.boardFlipped);
            }

            function undoMove() {
                // If there is a pending promotion, cancel it and revert to the previous snapshot
                if (gameState.pendingMove) {
                    restoreHistory();
                    return;
                }
                const restored = restoreHistory();
                if (!restored) return;
                gameState.pgnSynced = false;
            }

            function redoMove() {
                if (gameState.redoHistory.length === 0) return;
                // Before redo, push current state onto undo history so redo can be undone
                gameState.history.push(snapshotCurrent());
                const snap = gameState.redoHistory.pop();
                applySnapshot(snap);
                gameState.pgnSynced = false;
            }

            function resign() {
                if (gameState.gameOver) return;
                
                const winner = gameState.currentPlayer === 'white' ? 'Black' : 'White';
                gameState.gameOver = true;
                document.getElementById('gameStatus').textContent = `${winner} wins by resignation!`;
                document.getElementById('statusDetail').textContent = `${gameState.currentPlayer} resigned`;
                recordCompletedGame({ result: 'resignation', winner, reason: `${gameState.currentPlayer} resigned` });
                scheduleGameCompletionReport({
                    result: 'resignation',
                    winner,
                    reason: `${gameState.currentPlayer} resigned`,
                });
            }

            // ---------- FEN / PGN Support ----------
            function generateFEN() {
                // Board
                const rows = [];
                for (let r = 0; r < 8; r++) {
                    let empty = 0;
                    let rowStr = '';
                    for (let c = 0; c < 8; c++) {
                        const p = gameState.board[r][c];
                        if (!p) {
                            empty++;
                        } else {
                            if (empty > 0) { rowStr += String(empty); empty = 0; }
                            const isWhite = p[0] === 'w';
                            const code = p[1];
                            const map = { p:'p', r:'r', n:'n', b:'b', q:'q', k:'k' };
                            rowStr += isWhite ? map[code].toUpperCase() : map[code];
                        }
                    }
                    if (empty > 0) rowStr += String(empty);
                    rows.push(rowStr);
                }
                const boardPart = rows.join('/');
                // Active color
                const active = gameState.currentPlayer[0];
                // Castling
                let castle = '';
                if (gameState.castlingRights.wK) castle += 'K';
                if (gameState.castlingRights.wQ) castle += 'Q';
                if (gameState.castlingRights.bK) castle += 'k';
                if (gameState.castlingRights.bQ) castle += 'q';
                if (!castle) castle = '-';
                // En passant
                let ep = '-';
                if (gameState.enPassantTarget) {
                    const files = 'abcdefgh';
                    const [er, ec] = gameState.enPassantTarget;
                    ep = `${files[ec]}${8 - er}`;
                }
                // Halfmove / Fullmove
                const half = gameState.halfmoveClock || 0;
                const full = Math.floor(gameState.moveHistory.length / 2) + 1;
                return `${boardPart} ${active} ${castle} ${ep} ${half} ${full}`;
            }

            function loadFEN(fen, { preserveHistory = false } = {}) {
                try {
                    const parts = fen.trim().split(/\s+/);
                    if (parts.length < 4) throw new Error('Invalid FEN');
                    const [boardPart, active, castle, ep, halfStr, fullStr] = parts;
                    const rows = boardPart.split('/');
                    if (rows.length !== 8) throw new Error('Invalid FEN rows');
                    const board = Array.from({length:8},()=>Array(8).fill(''));
                    const decode = (ch) => {
                        const isWhite = ch === ch.toUpperCase();
                        const map = { p:'p', r:'r', n:'n', b:'b', q:'q', k:'k' };
                        const code = map[ch.toLowerCase()];
                        if (!code) return null;
                        return (isWhite ? 'w' : 'b') + code;
                    };
                    for (let r = 0; r < 8; r++) {
                        let c = 0;
                        for (const ch of rows[r]) {
                            if (/[1-8]/.test(ch)) {
                                c += parseInt(ch,10);
                            } else {
                                const piece = decode(ch);
                                if (!piece) throw new Error('Invalid FEN piece');
                                board[r][c] = piece;
                                c++;
                            }
                        }
                        if (c !== 8) throw new Error('Invalid FEN row width');
                    }
                    // Apply to game state
                    gameState.board = board;
                    gameState.currentPlayer = active === 'w' ? 'white' : 'black';
                    gameState.castlingRights = { wK:false, wQ:false, bK:false, bQ:false };
                    if (castle && castle !== '-') {
                        if (castle.includes('K')) gameState.castlingRights.wK = true;
                        if (castle.includes('Q')) gameState.castlingRights.wQ = true;
                        if (castle.includes('k')) gameState.castlingRights.bK = true;
                        if (castle.includes('q')) gameState.castlingRights.bQ = true;
                    }
                    if (ep && ep !== '-') {
                        const files = 'abcdefgh';
                        const file = files.indexOf(ep[0]);
                        const rank = parseInt(ep.slice(1),10);
                        if (file>=0 && rank>=1 && rank<=8) {
                            gameState.enPassantTarget = [8-rank, file];
                        } else {
                            gameState.enPassantTarget = null;
                        }
                    } else {
                        gameState.enPassantTarget = null;
                    }
                    gameState.halfmoveClock = halfStr ? parseInt(halfStr,10) || 0 : 0;
                    // Reset histories upon FEN load
                    if (!preserveHistory) {
                        gameState.moveHistory = [];
                        gameState.gameOver = false;
                        gameState.repetitionMap = {};
                        gameState.capturedByWhite = [];
                        gameState.capturedByBlack = [];
                        gameState.lastMove = null;
                    }
                    clearSelection();
                    updateBoardUI();
                    updateMoveHistory();
                    updatePlayerIndicators();
                    updateGameStatus();
                    updateCapturedUI();
                    recordRepetition();
                    const fenEl = document.getElementById('fenInput');
                    if (fenEl) fenEl.value = generateFEN();
                    if (!preserveHistory) {
                        resetEvaluationGraph();
                    }
                    updateVariationUI();
                } catch (e) {
                    alert('Failed to load FEN: ' + e.message);
                }
            }

            function buildPGN() {
                const headers = [
                    '[Event "Casual Game"]',
                    '[Site "?"]',
                    '[Date "????.??.??"]',
                    '[Round "-"]',
                    '[White "White"]',
                    '[Black "Black"]'
                ];
                let result = '*';
                if (gameState.gameOver) {
                    if ((document.getElementById('gameStatus').textContent || '').includes('Draw')) result = '1/2-1/2';
                    else result = gameState.currentPlayer === 'white' ? '0-1' : '1-0';
                }
                headers.push(`[Result "${result}"]`);
                // Moves
                const san = gameState.moveHistory.map(m => m.notation + (m.comment ? ` {${m.comment}}` : ''));
                const moves = [];
                for (let i = 0; i < san.length; i += 2) {
                    const num = Math.floor(i/2) + 1;
                    const whiteMove = san[i] || '';
                    const blackMove = san[i+1] || '';
                    if (blackMove) moves.push(`${num}. ${whiteMove} ${blackMove}`);
                    else moves.push(`${num}. ${whiteMove}`);
                }
                const body = moves.join(' ');
                const pgn = headers.join('\n') + `\n\n${body} ${result}`.trim();
                return pgn;
            }

            function exportPGN() {
                const pgn = buildPGN();
                // Copy to clipboard
                navigator.clipboard?.writeText(pgn).then(()=>{
                    alert('PGN copied to clipboard');
                }).catch(()=>{
                    alert('PGN:\n\n' + pgn);
                });
                return pgn;
            }

            document.getElementById('newGame').addEventListener('click', initializeBoard);
            document.getElementById('flipBoard').addEventListener('click', flipBoard);
            function clickUndoOrPrev() {
                const tools = document.getElementById('fenPgnTools');
                const inAnalysis = tools && tools.style.display !== 'none';
                const useRedoStack = !gameState.pgnSynced && gameState.redoHistory.length > 0;
                if (inAnalysis && gameState.replayMode && !useRedoStack && gameState.pgnMoves && gameState.pgnMoves.length > 0 && gameState.pgnSynced) {
                    if (gameState.pgnIndex > 0) {
                        pgnGoPrev();
                        return;
                    }
                }
                undoMove();
            }
            function clickRedoOrNext() {
                const tools = document.getElementById('fenPgnTools');
                const inAnalysis = tools && tools.style.display !== 'none';
                const useRedoStack = !gameState.pgnSynced && gameState.redoHistory.length > 0;
                if (inAnalysis && gameState.replayMode && !useRedoStack && gameState.pgnMoves && gameState.pgnMoves.length > 0 && gameState.pgnSynced) {
                    if (gameState.pgnIndex < gameState.pgnMoves.length) {
                        pgnGoNext();
                        return;
                    }
                }
                redoMove();
            }
            document.getElementById('undoMove').addEventListener('click', clickUndoOrPrev);
            document.getElementById('redoMove').addEventListener('click', clickRedoOrNext);
            document.getElementById('resign').addEventListener('click', resign);

            // Promotion modal events
            document.getElementById('promotionBackdrop').addEventListener('click', (e) => {
                if (e.target.id === 'promotionBackdrop') {
                    // Ignore backdrop click to force a choice, or allow cancel to default queen
                }
            });
            document.querySelectorAll('#promotionBackdrop .promo-btn[data-piece]').forEach(btn => {
                btn.addEventListener('click', () => applyPromotionChoice(btn.dataset.piece));
            });
            document.getElementById('promotionCancel').addEventListener('click', () => applyPromotionChoice('q'));

            // FEN / PGN events
            document.getElementById('loadFENBtn').addEventListener('click', () => {
                const fen = document.getElementById('fenInput').value.trim();
                if (fen) loadFEN(fen);
            });
            document.getElementById('copyFENBtn').addEventListener('click', () => {
                const fen = generateFEN();
                navigator.clipboard?.writeText(fen).then(()=>{
                    alert('FEN copied to clipboard');
                }).catch(()=>{
                    alert('FEN:\n\n' + fen);
                });
            });
            document.getElementById('exportPGNBtn').addEventListener('click', exportPGN);

            // Start screen navigation
            function enterAnalysisMode({ skipInit = false } = {}) {
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('appContainer').style.display = '';
                // Show FEN/PGN tools in analysis
                const tools = document.getElementById('fenPgnTools');
                if (tools) tools.style.display = '';
                // Rename Undo/Redo to Previous/Next and hide duplicate PGN Prev/Next
                const undoBtn = document.getElementById('undoMove');
                const redoBtn = document.getElementById('redoMove');
                if (undoBtn) undoBtn.textContent = 'Previous';
                if (redoBtn) redoBtn.textContent = 'Next';
                const pPrev = document.getElementById('pgnPrevBtn');
                const pNext = document.getElementById('pgnNextBtn');
                if (pPrev) pPrev.classList.add('hidden');
                if (pNext) pNext.classList.add('hidden');
                // Hide 'Open in Analysis' and 'Resign' in analysis mode
                const openBtn = document.getElementById('openInAnalysis');
                if (openBtn) openBtn.classList.add('hidden');
                const resignBtn = document.getElementById('resign');
                if (resignBtn) resignBtn.classList.add('hidden');
                const analyzeEngineBtn = document.getElementById('openInAnalysisEngine');
                if (analyzeEngineBtn) analyzeEngineBtn.classList.add('hidden');
                // Reset replay scaffolding when (re)entering analysis mode
                gameState.replayMode = true;
                if (gameState.pgnSynced === false) {
                    gameState.pgnMoves = gameState.moveHistory.map(m => m.notation);
                    gameState.pgnIndex = gameState.pgnMoves.length;
                } else {
                    gameState.pgnMoves = gameState.moveHistory.map(m => m.notation);
                    gameState.pgnIndex = gameState.pgnMoves.length;
                    gameState.pgnSynced = true;
                }
                // Only initialize once per session start of analysis
                if (!skipInit && (!gameState.board || gameState.board.length === 0 || gameState.moveHistory.length === 0)) {
                    initializeBoard();
                } else {
                    updateBoardUI();
                    updateMoveHistory();
                    updatePlayerIndicators();
                    updateGameStatus();
                }
                updateVariationUI();
            }
            function enterComputerPlayMode(opponentId, humanSide = 'white') {
                const success = setComputerMode(opponentId, humanSide);
                if (!success) {
                    alert('Unable to start computer game. Please try another opponent.');
                    return;
                }
                if (startScreen) startScreen.style.display = 'none';
                if (puzzleSection) puzzleSection.style.display = 'none';
                if (appContainer && !document.body.contains(appContainer)) {
                    document.body.appendChild(appContainer);
                }
                if (appContainer) appContainer.style.display = '';

                initializeBoard();

                const tools = document.getElementById('fenPgnTools');
                if (tools) tools.classList.add('hidden');
                const openBtn = document.getElementById('openInAnalysis');
                if (openBtn) openBtn.classList.remove('hidden');
                if (gameState.humanSide === 'black') {
                    setTimeout(() => {
                        requestComputerMove();
                    }, gameState.computerDelayMs || 350);
                }
                gameState.currentGameId = generateGameSessionId();
                gameState.gameStartTimestamp = Date.now();
                gameState.completedReported = false;
                ensureGameHistoryVisible();
                fetchCompletedGames();
            }

            function enterLocalPlayMode() {
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('appContainer').style.display = '';
                // Hide FEN/PGN tools in local play mode
                const tools = document.getElementById('fenPgnTools');
                if (tools) tools.classList.add('hidden');
                // Show quick link to analysis
                const openBtn = document.getElementById('openInAnalysis');
                if (openBtn) openBtn.classList.remove('hidden');
                const openEngineBtn = document.getElementById('openInAnalysisEngine');
                if (openEngineBtn) openEngineBtn.classList.remove('hidden');
                // Show resign in local play
                const resignBtn = document.getElementById('resign');
                if (resignBtn) resignBtn.classList.remove('hidden');
                // Restore Undo/Redo labels and show PGN Prev/Next in case they were hidden
                const undoBtn = document.getElementById('undoMove');
                const redoBtn = document.getElementById('redoMove');
                if (undoBtn) undoBtn.textContent = 'Undo Move';
                if (redoBtn) redoBtn.textContent = 'Redo Move';
                const pPrev = document.getElementById('pgnPrevBtn');
                const pNext = document.getElementById('pgnNextBtn');
                if (pPrev) pPrev.classList.remove('hidden');
                if (pNext) pNext.classList.remove('hidden');
                // Disable replay mode
                gameState.replayMode = false;
                gameState.pgnMoves = [];
                gameState.pgnIndex = 0;
                gameState.mode = 'local';
                gameState.currentGameId = generateGameSessionId();
                gameState.gameStartTimestamp = Date.now();
                gameState.completedReported = false;
                // Start fresh board
                initializeBoard();
                ensureGameHistoryVisible();
            }
            const legacyAnalyzeBtn = document.getElementById('btnAnalyzeGame');
            if (legacyAnalyzeBtn) legacyAnalyzeBtn.addEventListener('click', () => enterAnalysisMode());
            const legacyLocalBtn = document.getElementById('btnLocalPlay');
            if (legacyLocalBtn) legacyLocalBtn.addEventListener('click', enterLocalPlayMode);
            const onlineToggleBtn = document.getElementById('btnPlayOnline');
            const onlinePanel = document.getElementById('onlinePlayPanel');
            const onlineUsernameInput = document.getElementById('onlineUsername');
            const onlineCreateBtn = document.getElementById('onlineCreateBtn');
            const onlineColorSelect = document.getElementById('onlineColor');
            const onlineJoinInput = document.getElementById('onlineJoinId');
            const onlineJoinBtn = document.getElementById('onlineJoinBtn');
            const onlineStatus = document.getElementById('onlineStatus');
            const onlineShare = document.getElementById('onlineShare');
            const onlineShareLink = document.getElementById('onlineShareLink');
            const onlineGameMeta = document.getElementById('onlineGameMeta');
            const onlineActions = document.getElementById('onlineInGameActions');
            const onlineTurnStatus = document.getElementById('onlineTurnStatus');
            const onlineCopyBtn = document.getElementById('onlineCopyLink');
            const onlineResignBtn = document.getElementById('onlineResignBtn');
            const onlineLeaveBtn = document.getElementById('onlineLeaveBtn');

            function resolveOnlineWsUrl() {
                try {
                    const base = backendBase ? backendBase.replace(/\/$/, '') : window.location.origin;
                    const url = new URL(base);
                    url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
                    url.pathname = '/ws';
                    return url.toString();
                } catch (err) {
                    const fallback = window.location.origin.replace(/^http/, 'ws');
                    return `${fallback}/ws`;
                }
            }

            const ONLINE_WS_URL = resolveOnlineWsUrl();

            function setOnlineStatus(text, type = 'info') {
                onlineState.status = text;
                onlineState.statusType = type;
                if (!onlineStatus) return;
                onlineStatus.textContent = text;
                onlineStatus.classList.remove('online-status-error', 'online-status-success');
                if (type === 'error') {
                    onlineStatus.classList.add('online-status-error');
                } else if (type === 'success') {
                    onlineStatus.classList.add('online-status-success');
                }
            }

            function clearOnlineAutoLeaveTimer() {
                if (onlineState.autoLeaveTimer) {
                    clearTimeout(onlineState.autoLeaveTimer);
                    onlineState.autoLeaveTimer = null;
                }
            }

            function scheduleOnlineAutoLeave() {
                clearOnlineAutoLeaveTimer();
                if (!onlineState.inGame) return;
                onlineState.autoLeaveTimer = setTimeout(() => {
                    onlineState.autoLeaveTimer = null;
                    if (!onlineState.inGame) return;
                    setOnlineStatus('Disconnected too long. Leaving game.', 'error');
                    sendOnlineMessage({ type: 'leave', gameId: onlineState.gameId });
                    leaveOnlineGame({ reason: 'left' });
                    onlineState.manualDisconnect = true;
                    onlineState.pendingAction = null;
                    onlineState.pendingMessages = [];
                    if (onlineState.playerId) {
                        localStorage.removeItem(ONLINE_PLAYER_ID_STORAGE_KEY);
                    }
                    onlineState.desiredColor = 'random';
                    onlineState.shareUrl = '';
                    cleanupOnlineSocket();
                }, 60000);
            }

            function setOnlineShareLink(url = '') {
                const value = url || '';
                onlineState.shareUrl = value;
                if (onlineShareLink) {
                    onlineShareLink.value = value;
                    if (!value) {
                        onlineShareLink.setAttribute('placeholder', 'Waiting for lobby');
                    } else {
                        onlineShareLink.removeAttribute('placeholder');
                    }
                }
                if (onlineCopyBtn) {
                    onlineCopyBtn.disabled = !value;
                }
            }

            function resetOnlineUI() {
                if (onlineShare) hideElement(onlineShare);
                if (onlineActions) hideElement(onlineActions);
                setOnlineShareLink('');
                if (onlineGameMeta) onlineGameMeta.textContent = '';
                if (onlineTurnStatus) onlineTurnStatus.textContent = 'Waiting for opponent...';
                if (onlineJoinInput) onlineJoinInput.value = '';
            }

            function ensureOnlinePanelVisible() {
                if (!onlinePanel) return;
                onlinePanel.classList.remove('hidden');
            }

            function hideOnlinePanel() {
                if (!onlinePanel) return;
                onlinePanel.classList.add('hidden');
            }

            function cleanupOnlineSocket({ allowReconnect = false } = {}) {
                if (onlineState.heartbeatTimer) {
                    clearInterval(onlineState.heartbeatTimer);
                    onlineState.heartbeatTimer = null;
                }
                clearOnlineAutoLeaveTimer();
                if (onlineState.socket) {
                    try {
                        onlineState.socket.onopen = null;
                        onlineState.socket.onmessage = null;
                        onlineState.socket.onclose = null;
                        onlineState.socket.onerror = null;
                        onlineState.socket.close();
                    } catch (err) {
                        console.warn('Error closing online socket', err);
                    }
                }
                onlineState.socket = null;
                onlineState.connected = false;
                onlineState.connecting = false;
                onlineState.awaitingAckUci = null;
                onlineState.remoteApplying = false;
                onlineState.manualDisconnect = !allowReconnect;
                if (onlineState.reconnectTimer) {
                    clearTimeout(onlineState.reconnectTimer);
                    onlineState.reconnectTimer = null;
                }
            }

            function leaveOnlineGame({ reason = 'left' } = {}) {
                if (!onlineState.inGame) return;
                onlineState.inGame = false;
                onlineState.gameId = null;
                onlineState.assignedColor = null;
                onlineState.turn = 'white';
                hideElement(onlineActions);
                hideElement(onlineShare);
                onlineGameMeta.textContent = '';
                setOnlineShareLink('');
                onlineTurnStatus.textContent = reason === 'finished' ? 'Game over' : 'Waiting for opponent...';
                updateBoardUI();
                setOnlineStatus(reason === 'finished' ? 'Game finished' : 'Left the game', 'info');
                if (gameState.mode === 'online') {
                    gameState.mode = 'local';
                    resetPlayerPanels();
                }
                onlineState.pendingAction = null;
            }

            function resetPlayerPanels() {
                const whitePanel = document.getElementById('whitePlayer');
                const blackPanel = document.getElementById('blackPlayer');
                if (whitePanel) {
                    const nameEl = whitePanel.querySelector('.player-name');
                    const statusEl = whitePanel.querySelector('.player-status');
                    if (nameEl) nameEl.textContent = playerPanelDefaults.white.name;
                    if (statusEl) statusEl.textContent = playerPanelDefaults.white.status;
                }
                if (blackPanel) {
                    const nameEl = blackPanel.querySelector('.player-name');
                    const statusEl = blackPanel.querySelector('.player-status');
                    if (nameEl) nameEl.textContent = playerPanelDefaults.black.name;
                    if (statusEl) statusEl.textContent = playerPanelDefaults.black.status;
                }
            }

            function applyOnlineGameStart(payload) {
                const { gameId, fen, turn, color, white, black } = payload;
                if (!gameId || !fen) return;
                loadFEN(fen, { preserveHistory: true });
                gameState.mode = 'online';
                onlineState.inGame = true;
                onlineState.gameId = gameId;
                onlineState.assignedColor = color || 'white';
                onlineState.turn = turn || 'white';
                onlineTurnStatus.textContent = turn === onlineState.assignedColor ? 'Your move' : 'Opponent thinking';
                showElement(onlineActions);
                showElement(onlineShare);
                const startPanel = document.getElementById('startScreen');
                if (startPanel && !startPanel.classList.contains('hidden')) {
                    showPlay();
                }
                const hostName = white?.name || 'White';
                const guestName = black?.name || 'Black';
                onlineGameMeta.textContent = `${hostName} vs ${guestName}`;
                const shareUrl = generateOnlineShareUrl(gameId);
                setOnlineShareLink(shareUrl);
                setOnlineStatus(`Game started! You are ${onlineState.assignedColor}.`);
                updatePlayerPanelsForOnline({ white, black });
                onlineState.pendingAction = null;
            }

            function generateOnlineShareUrl(gameId) {
                try {
                    const base = new URL(window.location.href);
                    base.hash = '';
                    base.search = '';
                    base.pathname = base.pathname.replace(/index\.html$/, '').replace(/\/$/, '/');
                    base.searchParams.set('gameId', gameId);
                    return base.toString();
                } catch (err) {
                    return `${window.location.origin}?gameId=${gameId}`;
                }
            }

            function updatePlayerPanelsForOnline({ white, black }) {
                const whitePanel = document.getElementById('whitePlayer');
                const blackPanel = document.getElementById('blackPlayer');
                if (whitePanel) {
                    whitePanel.querySelector('.player-name').textContent = white?.name || 'White Player';
                    whitePanel.querySelector('.player-status').textContent = white?.playerId === onlineState.playerId ? 'You' : 'Opponent';
                }
                if (blackPanel) {
                    blackPanel.querySelector('.player-name').textContent = black?.name || 'Black Player';
                    blackPanel.querySelector('.player-status').textContent = black?.playerId === onlineState.playerId ? 'You' : 'Opponent';
                }
            }

            function applyOnlineMove(payload) {
                const { uci, turn, fen } = payload;
                if (!uci) return;
                const coords = uciToCoords(uci);
                if (!coords) {
                    console.warn('Unable to parse remote move', uci);
                    return;
                }
                onlineState.remoteApplying = true;
                try {
                    movePiece(coords.fr, coords.fc, coords.tr, coords.tc, { preserveRedo: true });
                } catch (err) {
                    console.warn('Failed to apply remote move', err);
                } finally {
                    onlineState.remoteApplying = false;
                }
                if (fen) {
                    try {
                        loadFEN(fen, { preserveHistory: true });
                    } catch (err) {
                        console.warn('Failed to sync board from fen', err);
                    }
                }
                onlineState.turn = turn || (onlineState.turn === 'white' ? 'black' : 'white');
                onlineTurnStatus.textContent = onlineState.turn === onlineState.assignedColor ? 'Your move' : 'Opponent thinking';
            }

            function handleOnlineGameOver(payload) {
                const { result, reason } = payload || {};
                setOnlineStatus(`Game over: ${result || reason || 'completed'}`, 'success');
                onlineTurnStatus.textContent = 'Game over';
                leaveOnlineGame({ reason: 'finished' });
            }

            function flushOnlineQueue() {
                if (!onlineState.pendingMessages.length) return;
                if (!onlineState.socket || onlineState.socket.readyState !== WebSocket.OPEN) return;
                while (onlineState.pendingMessages.length) {
                    const payload = onlineState.pendingMessages.shift();
                    try {
                        onlineState.socket.send(JSON.stringify(payload));
                    } catch (err) {
                        console.warn('Failed to send queued message', err);
                        break;
                    }
                }
            }

            function sendOnlineMessage(data) {
                if (!data || typeof data !== 'object') return;
                if (!onlineState.socket || onlineState.socket.readyState !== WebSocket.OPEN) {
                    console.log('[online] queue message', data?.type, {
                        readyState: onlineState.socket ? onlineState.socket.readyState : 'no-socket',
                    });
                    onlineState.pendingMessages.push(data);
                    return;
                }
                try {
                    console.log('[online] send', data.type, data);
                    onlineState.socket.send(JSON.stringify(data));
                } catch (err) {
                    console.warn('Failed to send message', err);
                }
            }

            function sendOnlineMove(fr, fc, tr, tc, promotion) {
                if (!onlineState.inGame) {
                    console.log('[online] skip send - not in game');
                    return;
                }
                if (onlineState.turn !== onlineState.assignedColor) {
                    console.log('[online] skip send - wrong turn', {
                        turn: onlineState.turn,
                        assigned: onlineState.assignedColor,
                    });
                    return;
                }
                const uci = moveToUci(fr, fc, tr, tc, promotion);
                onlineState.awaitingAckUci = uci;
                sendOnlineMessage({
                    type: 'move',
                    gameId: onlineState.gameId,
                    playerId: onlineState.playerId,
                    uci,
                });
            }

            function handleOnlineMessage(event) {
                let payload = null;
                try {
                    payload = JSON.parse(event.data);
                } catch (err) {
                    console.warn('Invalid online message', event.data);
                    return;
                }
                if (!payload || typeof payload.type !== 'string') return;
                switch (payload.type) {
                    case 'hello':
                        onlineState.playerId = payload.playerId;
                        if (onlineState.playerId) {
                            localStorage.setItem(ONLINE_PLAYER_ID_STORAGE_KEY, onlineState.playerId);
                        }
                        onlineState.handshakeComplete = true;
                        flushOnlineQueue();
                        setOnlineStatus('Connected to online service', 'success');
                        if (onlineState.pendingAction === 'resume' && payload.gameId) {
                            sendOnlineMessage({ type: 'join', gameId: payload.gameId });
                        }
                        break;
                    case 'created':
                        setOnlineStatus(`Lobby created. Share ID ${payload.gameId}`, 'success');
                        setOnlineShareLink(generateOnlineShareUrl(payload.gameId));
                        showElement(onlineShare);
                        onlineState.gameId = payload.gameId;
                        onlineState.assignedColor = payload.color || 'white';
                        break;
                    case 'start':
                        applyOnlineGameStart(payload);
                        break;
                    case 'move':
                        if (onlineState.awaitingAckUci && payload.uci === onlineState.awaitingAckUci) {
                            onlineState.awaitingAckUci = null;
                            onlineState.turn = payload.turn || (onlineState.turn === 'white' ? 'black' : 'white');
                            if (payload.fen) {
                                try {
                                    loadFEN(payload.fen);
                                } catch (err) {
                                    console.warn('Failed to sync board from ack fen', err);
                                }
                            }
                            onlineTurnStatus.textContent = onlineState.turn === onlineState.assignedColor ? 'Your move' : 'Opponent thinking';
                        } else {
                            applyOnlineMove(payload);
                        }
                        break;
                    case 'game_over':
                        handleOnlineGameOver(payload);
                        break;
                    case 'resume':
                        applyOnlineGameStart(payload);
                        if (Array.isArray(payload.moves)) {
                            payload.moves.forEach((move) => applyOnlineMove({ uci: move.uci, turn: payload.turn, fen: move.fenAfter }));
                        }
                        if (payload.result) {
                            handleOnlineGameOver(payload);
                        }
                        break;
                    case 'left':
                        if (payload.gameId && payload.gameId === onlineState.gameId) {
                            leaveOnlineGame({ reason: 'left' });
                            onlineState.manualDisconnect = true;
                            onlineState.pendingAction = null;
                            clearOnlineAutoLeaveTimer();
                            cleanupOnlineSocket();
                        }
                        setOnlineStatus('Left the game due to inactivity.', 'info');
                        break;
                    case 'opponent_disconnect':
                        setOnlineStatus('Opponent disconnected. Waiting for reconnection', 'info');
                        if (onlineTurnStatus) onlineTurnStatus.textContent = 'Opponent disconnected';
                        break;
                    case 'ping':
                        sendOnlineMessage({ type: 'pong' });
                        break;
                    case 'error':
                        setOnlineStatus(payload.msg || 'Server error', 'error');
                        break;
                    default:
                        console.warn('Unhandled online payload', payload);
                }
            }

            function connectOnlineSocket() {
                if (onlineState.connecting || onlineState.connected) return;
                cleanupOnlineSocket({ allowReconnect: true });
                setOnlineStatus('Connecting');
                onlineState.connecting = true;
                const ws = new WebSocket(ONLINE_WS_URL);
                onlineState.socket = ws;

                ws.onopen = () => {
                    onlineState.connecting = false;
                    onlineState.connected = true;
                    onlineState.manualDisconnect = false;
                    onlineState.handshakeComplete = false;
                    onlineState.disconnectedAt = null;
                    clearOnlineAutoLeaveTimer();
                    setOnlineStatus('Connected', 'success');
                    const payload = {
                        type: 'hello',
                        playerId: onlineState.playerId,
                        username: onlineState.username || null,
                        gameId: onlineState.gameId || null,
                    };
                    sendOnlineMessage(payload);
                    flushOnlineQueue();
                };

                ws.onmessage = handleOnlineMessage;

                ws.onerror = (err) => {
                    console.warn('Online socket error', err);
                    setOnlineStatus('Connection error', 'error');
                };

                ws.onclose = () => {
                    onlineState.connected = false;
                    onlineState.handshakeComplete = false;
                    if (!onlineState.manualDisconnect) {
                        onlineState.disconnectedAt = Date.now();
                        scheduleOnlineAutoLeave();
                    }
                    if (onlineState.inGame) {
                        setOnlineStatus('Connection lost. Attempting to reconnect', 'error');
                        onlineState.pendingAction = 'resume';
                    }
                    if (onlineState.manualDisconnect) {
                        setOnlineStatus('Disconnected');
                        cleanupOnlineSocket();
                        return;
                    }
                    setOnlineStatus('Disconnected. Retrying', 'error');
                    onlineState.reconnectTimer = setTimeout(connectOnlineSocket, 3000);
                };
            }

            function ensureOnlineConnection() {
                if (onlineState.connected || onlineState.connecting) return;
                connectOnlineSocket();
            }

            function handleOnlineCreate() {
                ensureOnlineConnection();
                onlineState.desiredColor = onlineColorSelect?.value || 'random';
                sendOnlineMessage({ type: 'create', color: onlineState.desiredColor });
                setOnlineStatus('Creating lobby');
                if (onlineShare) showElement(onlineShare);
                setOnlineShareLink('');
            }

            function handleOnlineJoin() {
                ensureOnlineConnection();
                const gameId = onlineJoinInput.value.trim().toUpperCase();
                if (!gameId) {
                    setOnlineStatus('Enter a game ID to join', 'error');
                    return;
                }
                sendOnlineMessage({ type: 'join', gameId });
                setOnlineStatus(`Joining game ${gameId}`);
            }

            function handleOnlineResign() {
                if (!onlineState.inGame) return;
                sendOnlineMessage({ type: 'resign', gameId: onlineState.gameId });
                setOnlineStatus('You resigned', 'info');
                leaveOnlineGame({ reason: 'finished' });
            }

            function handleOnlineLeave() {
                leaveOnlineGame({ reason: 'left' });
                cleanupOnlineSocket();
                hideOnlinePanel();
                setOnlineStatus('Not connected');
                resetOnlineUI();
                onlineState.manualDisconnect = true;
            }

            function initializeOnlineUI() {
                if (!onlineToggleBtn) return;
                onlineToggleBtn.addEventListener('click', () => {
                    if (!onlinePanel) return;
                    if (onlinePanel.classList.contains('hidden')) {
                        ensureOnlinePanelVisible();
                        ensureOnlineConnection();
                    } else {
                        hideOnlinePanel();
                        cleanupOnlineSocket();
                    }
                });

                if (onlineUsernameInput) {
                    if (storedOnlineUsername) {
                        onlineUsernameInput.value = storedOnlineUsername;
                    }
                    onlineUsernameInput.addEventListener('change', () => {
                        onlineState.username = onlineUsernameInput.value.trim();
                        localStorage.setItem(ONLINE_USERNAME_STORAGE_KEY, onlineState.username);
                        if (onlineState.connected) {
                            sendOnlineMessage({ type: 'hello', playerId: onlineState.playerId, username: onlineState.username });
                        }
                    });
                }

                if (onlineCreateBtn) onlineCreateBtn.addEventListener('click', handleOnlineCreate);
                if (onlineJoinBtn) onlineJoinBtn.addEventListener('click', handleOnlineJoin);
                if (onlineResignBtn) onlineResignBtn.addEventListener('click', handleOnlineResign);
                if (onlineLeaveBtn) onlineLeaveBtn.addEventListener('click', handleOnlineLeave);
                if (onlineCopyBtn) {
                    onlineCopyBtn.addEventListener('click', async () => {
                        const link = onlineState.shareUrl;
                        if (!link) {
                            setOnlineStatus('Lobby not ready yet.', 'error');
                            return;
                        }
                        try {
                            await navigator.clipboard.writeText(link);
                            setOnlineStatus('Invite link copied!', 'success');
                            onlineCopyBtn.textContent = 'Copied!';
                            setTimeout(() => { onlineCopyBtn.textContent = 'Copy'; }, 1500);
                        } catch (err) {
                            setOnlineStatus('Unable to copy invite link', 'error');
                        }
                    });
                }
            }

            initializeOnlineUI();
            document.getElementById('btnAnalyzeWithComputer').addEventListener('click', () => {
                window.location.hash = '#analysis-engine';
            });
            const analysisToggleBtn = document.getElementById('analysisToggle');
            if (analysisToggleBtn) {
                analysisToggleBtn.addEventListener('click', () => {
                    setAnalysisEnabled(!analysisState.enabled);
                });
            }

            function findMoveMatchingSAN(san) {
                const legalMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = gameState.board[r][c];
                        if (!piece || piece[0] !== gameState.currentPlayer[0]) continue;
                        const moves = calculateValidMoves(r, c);
                        for (const [tr, tc, isEP, promo] of moves) {
                            if (leavesKingInCheck(r, c, tr, tc, isEP)) continue;
                            const preBoard = cloneBoard(gameState.board);
                            const capturedPiece = gameState.board[tr][tc];
                            const notation = getMoveNotation(r, c, tr, tc, capturedPiece, preBoard);
                            const result = { fr: r, fc: c, tr, tc, san: notation, promo };
                            legalMoves.push(result);
                        }
                    }
                }
                return legalMoves.find(m => m.san.replace(/[#\+]/g, '') === san.replace(/[#\+]/g, '')) || null;
            }

            // ---------- PGN Import / Replay ----------
            function parsePGN(pgnText) {
                const text = pgnText.replace(/\r/g, '\n');
                const headers = {};
                const headerRegex = /\[(\w+)\s+"([^"]*)"\]/g;
                let hm;
                while ((hm = headerRegex.exec(text)) !== null) headers[hm[1]] = hm[2];
                // Keep body including parentheses; remove headers and comments/NAGs
                let body = text.replace(headerRegex, ' ')
                    .replace(/;.*$/gm, ' ')
                    .replace(/\$\d+/g, ' ')
                    .trim();
                // Extract variations by tracking parentheses depth and mainline tokens
                const variations = {}; // index -> array<array<string>>
                let depth = 0;
                let token = '';
                let mainTokens = [];
                let currentVar = '';
                let mainCount = 0;
                const flushToken = (target) => {
                    const t = target.trim();
                    if (!t) return;
                    if (/^\d+\.(\.\.\.)?$/.test(t)) return;
                    if (/^(1-0|0-1|1\/2-1\/2|\*)$/.test(t)) return;
                    if (target === 'main') return;
                    if (target === 'var') return;
                };
                const pushMain = (t) => {
                    if (!/^\d+\.(\.\.\.)?$/.test(t) && !/^(1-0|0-1|1\/2-1\/2|\*)$/.test(t) && !/^\{.*\}$/.test(t)) {
                        mainTokens.push(t);
                        mainCount++;
                    }
                };
                const cleanToken = (t) => t.trim();
                // Iterate characters to split on whitespace and parentheses while preserving them
                let i = 0;
                while (i < body.length) {
                    const ch = body[i];
                    if (ch === '{') { // skip comments
                        const end = body.indexOf('}', i+1);
                        i = end === -1 ? body.length : end + 1;
                        continue;
                    }
                    if (ch === '(') {
                        // Starting a variation at current mainCount
                        depth++;
                        // Collect until matching ')'
                        let j = i + 1, d = 1, varText = '';
                        while (j < body.length && d > 0) {
                            if (body[j] === '(') d++;
                            else if (body[j] === ')') d--;
                            if (d > 0) varText += body[j];
                            j++;
                        }
                        i = j; // continue after ')'
                        // Tokenize this variation
                        const varTokens = varText.split(/\s+/)
                            .map(cleanToken)
                            .filter(t => t && !/^\d+\.(\.\.\.)?$/.test(t) && !/^(1-0|0-1|1\/2-1\/2|\*)$/.test(t));
                        if (!variations[mainCount]) variations[mainCount] = [];
                        variations[mainCount].push(varTokens);
                        continue;
                    }
                    if (ch === ')') { depth = Math.max(0, depth-1); i++; continue; }
                    if (/\s/.test(ch)) {
                        const t = cleanToken(token);
                        if (t) pushMain(t);
                        token = '';
                        i++;
                        continue;
                    }
                    token += ch;
                    i++;
                }
                if (token) pushMain(cleanToken(token));
                return { headers, moves: mainTokens, variations };
            }

            function pgnSetStartFromHeaders(headers = {}) {
                const fenHeader = headers?.FEN;
                const setupFlag = headers?.SetUp;
                const defaultFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
                const fenToLoad = (setupFlag === '1' && fenHeader) ? fenHeader : defaultFen;
                loadFEN(fenToLoad);
                gameState.moveHistory = [];
                gameState.history = [];
                gameState.redoHistory = [];
                gameState.pgnSynced = true;
                gameState.pgnIndex = 0;
                gameState.pgnMoves = [];
                gameState.replayMode = true;
                clearVariationLines();
                updateVariationUI();
            }

            function pgnLoad(text) {
                const { headers, moves: mainMoves, variations } = parsePGN(text);
                pgnSetStartFromHeaders(headers);
                gameState.pgnMoves = mainMoves.slice();
                gameState.pgnIndex = 0;
                gameState.replayMode = true;
                gameState.pgnSynced = true;
                clearVariationLines();
                ensureVariationStructures();
                const mainLineId = ensureActiveLineRegistered();
                if (mainLineId) gameState.activeLineId = mainLineId;
                if (variations) {
                    Object.entries(variations).forEach(([plyStr, seqs]) => {
                        const ply = parseInt(plyStr, 10) || 0;
                        const prefix = gameState.pgnMoves.slice(0, ply);
                        seqs.forEach((variationMoves, idx) => {
                            const combined = prefix.concat(variationMoves);
                            const label = variationMoves[0] ? `${Math.floor(ply / 2) + 1}. ${variationMoves[0]}` : `Line ${idx + 1}`;
                            registerVariationLine(combined, ply, label);
                        });
                    });
                }
                updateVariationUI();
            }

            function pgnGoStart() {
                if (!gameState.replayMode) return;
                // reload starting position from headers is not stored; simply re-run load with current pgnInput
                const txt = document.getElementById('pgnInput').value;
                pgnLoad(txt);
            }

            function pgnGoNext() {
                if (!gameState.replayMode) return;
                if (gameState.pgnIndex >= gameState.pgnMoves.length) return;
                const san = gameState.pgnMoves[gameState.pgnIndex];
                const match = findMoveMatchingSAN(san);
                if (!match) { alert('Cannot match SAN: ' + san); return; }
                if (match.promo) gameState.replayPromotionChoice = match.promo;
                gameState.executingPGN = true;
                try {
                    movePiece(match.fr, match.fc, match.tr, match.tc, { preserveRedo: true });
                    gameState.pgnSynced = true;
                } finally {
                    gameState.executingPGN = false;
                }
                gameState.pgnIndex++;
                updateVariationUI();
            }

            function pgnGoPrev() {
                if (!gameState.replayMode) return;
                if (gameState.pgnIndex <= 0) return;
                undoMove();
                gameState.pgnIndex--;
                updateVariationUI();
            }

            function pgnGoEnd() {
                if (!gameState.replayMode) return;
                while (gameState.pgnIndex < gameState.pgnMoves.length) {
                    pgnGoNext();
                }
            }

            document.getElementById('loadPGNBtn').addEventListener('click', () => {
                const txt = document.getElementById('pgnInput').value.trim();
                if (!txt.trim()) return;
                pgnLoad(txt);
            });
            document.getElementById('pgnStartBtn').addEventListener('click', pgnGoStart);
            document.getElementById('pgnPrevBtn').addEventListener('click', pgnGoPrev);
            document.getElementById('pgnNextBtn').addEventListener('click', pgnGoNext);
            document.getElementById('pgnEndBtn').addEventListener('click', pgnGoEnd);
            // Autoplay
            function pgnTogglePlay() {
                const btn = document.getElementById('pgnPlayBtn');
                if (!gameState.replayMode || !gameState.pgnSynced) return;
                gameState.autoplayMs = parseInt(document.getElementById('pgnSpeed').value,10) || 800;
                if (gameState.autoplaying) {
                    clearInterval(gameState.autoplayTimer);
                    gameState.autoplaying = false;
                    btn.textContent = 'Play ';
                } else {
                    btn.textContent = 'Pause ';
                    gameState.autoplaying = true;
                    gameState.autoplayTimer = setInterval(() => {
                        if (!gameState.replayMode || !gameState.pgnSynced) { pgnTogglePlay(); return; }
                        if (gameState.pgnIndex >= gameState.pgnMoves.length) { pgnTogglePlay(); return; }
                        pgnGoNext();
                    }, gameState.autoplayMs);
                }
            }
            document.getElementById('pgnPlayBtn').addEventListener('click', pgnTogglePlay);
            // Variations UI
            function ensureVariationStructures() {
                if (!Array.isArray(gameState.variationLines)) gameState.variationLines = [];
                if (!gameState.variationLineIndex || typeof gameState.variationLineIndex !== 'object') gameState.variationLineIndex = {};
                if (typeof gameState.variationCounter !== 'number') gameState.variationCounter = 0;
                if (!gameState.activeLineId && gameState.variationLines.length) {
                    gameState.activeLineId = gameState.variationLines[0].id;
                }
            }
            function clearVariationLines() {
                gameState.variationLines = [];
                gameState.variationLineIndex = {};
                gameState.variationCounter = 0;
                gameState.activeLineId = null;
            }
            function signatureFromMoves(moves) {
                return moves.map(m => String(m).trim()).filter(Boolean).join(' ');
            }
            function formatLineLabel(startPly, firstMove, lineNumber) {
                const base = `Line ${lineNumber}`;
                if (!firstMove) return base;
                const moveNumber = Math.floor(startPly / 2) + 1;
                const prefix = (startPly % 2 === 0) ? `${moveNumber}.` : `${moveNumber}...`;
                return `${base}: ${prefix} ${firstMove}`;
            }
            function upsertVariationLine({ moves, startPly = 0, label, existingId } = {}) {
                ensureVariationStructures();
                if (!Array.isArray(moves)) return null;
                const sanitized = moves.map(m => String(m).trim()).filter(Boolean);
                if (!sanitized.length) return null;
                console.debug('[variation] upsertVariationLine', { moves: sanitized, startPly, label, existingId, variationCounter: gameState.variationCounter });
                const signature = signatureFromMoves(sanitized);
                const start = Math.max(0, Math.min(startPly, sanitized.length));
                if (signature && gameState.variationLineIndex[signature]) {
                    const id = gameState.variationLineIndex[signature];
                    const entry = gameState.variationLines.find(l => l.id === id);
                    if (entry) {
                        console.debug('[variation] updating existing line via signature', { id, signature, start });
                        entry.moves = sanitized;
                        entry.startPly = start;
                        entry.prefix = sanitized.slice(0, start);
                        entry.branch = sanitized.slice(start);
                        entry.signature = signature;
                        if (label) entry.label = label;
                    }
                    return id;
                }
                if (existingId) {
                    const existing = gameState.variationLines.find(l => l.id === existingId);
                    if (existing) {
                        console.debug('[variation] updating existing line via id', { existingId, signature, start });
                        if (existing.signature) delete gameState.variationLineIndex[existing.signature];
                        existing.moves = sanitized;
                        existing.startPly = start;
                        existing.prefix = sanitized.slice(0, start);
                        existing.branch = sanitized.slice(start);
                        existing.signature = signature;
                        if (label) existing.label = label;
                        gameState.variationLineIndex[signature] = existing.id;
                        return existing.id;
                    }
                }
                gameState.variationCounter += 1;
                const id = `line${gameState.variationCounter}`;
                const entry = {
                    id,
                    label: label || formatLineLabel(start, sanitized[start] || sanitized[0], gameState.variationCounter),
                    moves: sanitized,
                    startPly: start,
                    prefix: sanitized.slice(0, start),
                    branch: sanitized.slice(start),
                    signature,
                };
                if (signature) gameState.variationLineIndex[signature] = id;
                gameState.variationLines.push(entry);
                console.debug('[variation] registered new line', entry, 'total', gameState.variationLines.length);
                return id;
            }
            function registerVariationLine(moves, startPly = 0, label) {
                const id = upsertVariationLine({ moves, startPly, label });
                console.debug('[variation] registerVariationLine result', { moves, startPly, label, id, lines: gameState.variationLines });
                return id;
            }
            function updateVariationUI() {
                ensureVariationStructures();
                ensureActiveLineRegistered();
                const bar = document.getElementById('pgnVariations');
                if (!bar) return;
                const lines = gameState.variationLines.slice();
                if (!lines.length) { bar.classList.add('hidden'); bar.innerHTML = ''; return; }
                if (lines.length <= 1) { bar.classList.add('hidden'); bar.innerHTML = ''; return; }
                bar.classList.remove('hidden');
                bar.innerHTML = '';
                const title = document.createElement('div');
                title.textContent = 'Lines:';
                title.style.marginRight = '6px';
                bar.appendChild(title);
                lines.forEach(line => {
                    const btn = document.createElement('button');
                    btn.textContent = line.label;
                    if (line.id === gameState.activeLineId) {
                        btn.disabled = true;
                        btn.classList.add('active');
                    } else {
                        btn.addEventListener('click', () => chooseVariationLine(line.id));
                    }
                    bar.appendChild(btn);
                });
            }
            function ensureActiveLineRegistered({ label } = {}) {
                ensureVariationStructures();
                const moves = (Array.isArray(gameState.pgnMoves) && gameState.pgnMoves.length)
                    ? gameState.pgnMoves.slice()
                    : gameState.moveHistory.map(m => m.notation).filter(Boolean);
                const signature = signatureFromMoves(moves);
                if (!signature) return null;
                const startPly = Math.max(0, Math.min((typeof gameState.pgnIndex === 'number' ? gameState.pgnIndex : gameState.moveHistory.length), moves.length));
                console.debug('[variation] ensureActiveLineRegistered', { moves, signature, startPly, activeLineId: gameState.activeLineId });
                if (gameState.activeLineId) {
                    const id = upsertVariationLine({ moves, startPly, existingId: gameState.activeLineId, label });
                    if (id) gameState.activeLineId = id;
                    return gameState.activeLineId;
                }
                const existingBySignature = gameState.variationLineIndex[signature];
                const id = upsertVariationLine({ moves, startPly, existingId: existingBySignature, label });
                if (id) gameState.activeLineId = id;
                return id;
            }
            function rewindToStart() {
                let guard = 1024;
                while (gameState.moveHistory.length > 0 && guard-- > 0) {
                    undoMove();
                }
                if (gameState.moveHistory.length > 0) {
                    console.warn('Unable to fully rewind analysis position');
                }
                gameState.history = [];
                gameState.redoHistory = [];
                gameState.lastMove = null;
                gameState.pgnIndex = 0;
                gameState.pgnSynced = true;
                gameState.replayMode = true;
            }
            function replayMovesToIndex(target) {
                if (!Array.isArray(gameState.pgnMoves)) gameState.pgnMoves = [];
                const count = Math.max(0, Math.min(target, gameState.pgnMoves.length));
                if (count === 0) {
                    updateBoardUI();
                    updateMoveHistory();
                    updatePlayerIndicators();
                    updateGameStatus();
                    return;
                }
                const seq = gameState.pgnMoves.slice(0, count);
                playSANSequence(seq);
                gameState.pgnIndex = count;
                gameState.pgnSynced = true;
            }
            function loadLineMoves(lineId) {
                ensureVariationStructures();
                const line = gameState.variationLines.find(l => l.id === lineId);
                if (!line) return;
                console.debug('[variation] loadLineMoves', { lineId, line, variationLines: gameState.variationLines });
                const prefixMoves = Array.isArray(line.prefix) ? line.prefix.slice() : line.moves.slice(0, line.startPly);
                const branchMoves = Array.isArray(line.branch) ? line.branch.slice() : line.moves.slice(line.startPly);
                const combined = prefixMoves.concat(branchMoves);
                gameState.activeLineId = lineId;
                gameState.replayMode = true;
                // Reset board to initial position
                rewindToStart();
                gameState.history = [];
                gameState.redoHistory = [];
                gameState.moveHistory = [];
                // Prepare PGN navigation
                gameState.pgnMoves = combined.slice();
                gameState.pgnIndex = 0;
                if (prefixMoves.length) {
                    playSANSequence(prefixMoves);
                    gameState.pgnIndex = prefixMoves.length;
                } else {
                    updateBoardUI();
                    updatePlayerIndicators();
                    updateGameStatus();
                }
                gameState.pgnSynced = true;
                updateMoveHistory();
                updateVariationUI();
                onAnalysisPositionChanged();
            }
            function chooseVariationLine(lineId) {
                ensureVariationStructures();
                if (!lineId || lineId === gameState.activeLineId) return;
                console.debug('[variation] chooseVariationLine', { lineId, activeLineId: gameState.activeLineId });
                ensureActiveLineRegistered();
                loadLineMoves(lineId);
            }

            // Play a sequence of SAN moves without creating new variation records
            function playSANSequence(seq) {
                for (const raw of seq) {
                    const san = String(raw).replace(/\{[^}]*\}/g, '').trim();
                    if (!san) continue;
                    const match = findMoveMatchingSAN(san);
                    if (!match) break;
                    if (match.promo) gameState.replayPromotionChoice = match.promo;
                    gameState.executingPGN = true;
                    try { movePiece(match.fr, match.fc, match.tr, match.tc); }
                    finally { gameState.executingPGN = false; }
                }
            }
            // Move comments
            function saveCurrentComment() {
                const txt = document.getElementById('moveComment').value.trim();
                let idx = -1;
                if (gameState.replayMode && gameState.pgnIndex > 0) idx = gameState.pgnIndex - 1;
                else idx = gameState.moveHistory.length - 1;
                if (idx >= 0 && idx < gameState.moveHistory.length) {
                    gameState.moveHistory[idx].comment = txt;
                    updateMoveHistory();
                }
            }
            document.getElementById('saveCommentBtn').addEventListener('click', saveCurrentComment);

            // From local play: open current game in analysis
            function openCurrentInAnalysis({ engine = false } = {}) {
                const currentFen = generateFEN();
                const pgnText = buildPGN();
                pendingAnalysisLoad = {
                    fen: currentFen,
                    pgn: pgnText,
                    engine,
                };
                exitComputerMode();
                navigateToAnalysis({ engine });
            }
            document.getElementById('openInAnalysis').addEventListener('click', openCurrentInAnalysis);
            const openInAnalysisEngineBtn = document.getElementById('openInAnalysisEngine');
            if (openInAnalysisEngineBtn) openInAnalysisEngineBtn.addEventListener('click', () => openCurrentInAnalysis({ engine: true }));

            const startScreen = document.getElementById('startScreen');
            const puzzleSection = document.getElementById('puzzleContainer');
            const appContainer = document.getElementById('appContainer');

            const getEl = (id) => document.getElementById(id);

            function hideElement(el) {
                if (!el) return;
                el.classList.add('hidden');
                if (el instanceof HTMLElement) {
                    el.hidden = true;
                }
            }

            function showElement(el) {
                if (!el) return;
                el.classList.remove('hidden');
                if (el instanceof HTMLElement) {
                    el.hidden = false;
                }
            }

            function resetAnalysisUI() {
                setAnalysisEnabled(false, { hidePanel: true });
                hideElement(getEl('analysisPanel'));
                hideElement(getEl('analysisButtons'));
                hideElement(getEl('analyzeWithEngineGlobal'));
                hideEngineVisuals();
                hideElement(getEl('pgnVariations'));
                resetEvaluationGraph();
                updateEngineEvalBar();
            }

            function hideEngineVisuals() {
                hideElement(getEl('engineEvalBar'));
                hideElement(getEl('evaluationGraphPanel'));
            }

            function showEngineVisuals() {
                showElement(getEl('engineEvalBar'));
                showElement(getEl('evaluationGraphPanel'));
            }

            function toggleEngineAnalysisSections(show) {
                const sectionIds = ['analysisStatus', 'analysisScore', 'analysisDepth', 'analysisLines'];
                sectionIds.forEach((id) => {
                    const el = getEl(id);
                    if (!el) return;
                    if (show) {
                        showElement(el);
                    } else {
                        hideElement(el);
                    }
                });
            }

            function showPgnVariationsContainer() {
                const variations = getEl('pgnVariations');
                if (!variations) return;
                showElement(variations);
            }

            function hidePgnVariationsContainer() {
                hideElement(getEl('pgnVariations'));
            }

            hideElement(appContainer);
            hideElement(puzzleSection);

            function ensureAppContainerInBody() {
                if (!appContainer) return;
                if (appContainer.parentElement !== document.body) {
                    document.body.appendChild(appContainer);
                }
            }

            function showHome() {
                setActiveView('home');
                ensureAppContainerInBody();
                if (startScreen) {
                    startScreen.classList.remove('hidden');
                    startScreen.hidden = false;
                    startScreen.style.display = '';
                }
                const boardControls = getEl('boardControls');
                const fenTools = getEl('fenPgnTools');
                hideElement(boardControls);
                hideElement(fenTools);
                hideElement(getEl('analysisPanel'));
                hideElement(getEl('analysisButtons'));
                hideElement(getEl('analyzeWithEngineGlobal'));
                hideElement(puzzleSection);
                hideElement(appContainer);
                exitComputerMode();
                setAnalysisEnabled(false, { hidePanel: true });
                hideEngineVisuals();
                hidePgnVariationsContainer();
                window.scrollTo(0, 0);
            }

            function showPlay() {
                const inOnlineGame = Boolean(onlineState?.inGame);

                setActiveView('play');
                hideElement(startScreen);
                ensureAppContainerInBody();
                showElement(appContainer);
                hideElement(puzzleSection);

                const newGameBtn = getEl('newGame');
                showElement(newGameBtn);
                const boardControls = getEl('boardControls');
                showElement(boardControls);
                const puzzleControls = getEl('puzzleControls');
                hideElement(puzzleControls);
                hidePuzzleBoard();

                if (!inOnlineGame) {
                    exitComputerMode();
                    setAnalysisEnabled(false, { hidePanel: true });
                    hideElement(getEl('analysisPanel'));
                    hideElement(getEl('analysisButtons'));
                    hideElement(getEl('analyzeWithEngineGlobal'));
                    hideEngineVisuals();
                    hidePgnVariationsContainer();
                    hideElement(getEl('fenPgnTools'));
                    enterLocalPlayMode();
                }

                ensureBoardReady();
                ensureGameHistoryVisible();
            }

            function showComputer() {
                setActiveView('computer');
                hideElement(startScreen);
                ensureAppContainerInBody();
                showElement(appContainer);
                hideElement(puzzleSection);
                const newGameBtn = getEl('newGame');
                showElement(newGameBtn);
                const boardControls = getEl('boardControls');
                showElement(boardControls);
                const puzzleControls = getEl('puzzleControls');
                hideElement(puzzleControls);
                hidePuzzleBoard();
                if (gameState.mode !== 'computer') {
                    setAnalysisEnabled(false, { hidePanel: true });
                    openOpponentModal(document.getElementById('navComputer') || document.getElementById('linkPlayComputer'));
                } else {
                    updatePlayerPanelsForMode();
                }
                hideElement(getEl('analysisPanel'));
                hideElement(getEl('analysisButtons'));
                hideElement(getEl('analyzeWithEngineGlobal'));
                hideEngineVisuals();
                hidePgnVariationsContainer();
                hideElement(getEl('fenPgnTools'));
                const openBtn = getEl('openInAnalysis');
                showElement(openBtn);
                const openEngineBtn = getEl('openInAnalysisEngine');
                showElement(openEngineBtn);
            }

            function showAnalysis(options = {}) {
                const { enableEngine = false } = options;
                const loadRequest = pendingAnalysisLoad;
                const engineRequested = enableEngine || !!(loadRequest && loadRequest.engine);
                setActiveView(engineRequested ? 'analysis-engine' : 'analysis');
                hideElement(startScreen);
                ensureAppContainerInBody();
                showElement(appContainer);
                hideElement(puzzleSection);
                const newGameBtn = getEl('newGame');
                showElement(newGameBtn);
                const boardControls = getEl('boardControls');
                showElement(boardControls);
                const puzzleControls = getEl('puzzleControls');
                hideElement(puzzleControls);
                hidePuzzleBoard();
                exitComputerMode();
                const shouldSkipInit = Boolean(pendingAnalysisLoad);
                enterAnalysisMode({ skipInit: shouldSkipInit });
                if (gameState.analysisWorker) {
                    gameState.analysisWorker.terminate();
                    gameState.analysisWorker = null;
                }
                const analysisButtons = getEl('analysisButtons');
                const analyzeEngineBtn = getEl('analyzeWithEngineGlobal');
                const analysisPanel = getEl('analysisPanel');
                const fenTools = getEl('fenPgnTools');
                if (fenTools) showElement(fenTools);
                showPgnVariationsContainer();
                if (engineRequested) {
                    setAnalysisEnabled(true);
                    showElement(analysisButtons);
                    showElement(analyzeEngineBtn);
                    showElement(analysisPanel);
                    showEngineVisuals();
                } else {
                    setAnalysisEnabled(false, { hidePanel: false });
                    hideElement(analysisButtons);
                    showElement(analyzeEngineBtn);
                    if (analysisPanel) showElement(analysisPanel);
                    hideEngineVisuals();
                }
                if (loadRequest) {
                    const { fen, pgn } = loadRequest;
                    if (fen) {
                        const fenInput = document.getElementById('fenInput');
                        if (fenInput) fenInput.value = fen;
                        loadFEN(fen);
                    }
                    if (pgn) {
                        const pgnArea = document.getElementById('pgnInput');
                        if (pgnArea) {
                            pgnArea.value = pgn;
                            pgnLoad(pgn);
                            gameState.history = [];
                            gameState.redoHistory = [];
                            playSANSequence(gameState.pgnMoves);
                            gameState.pgnIndex = gameState.pgnMoves.length;
                            gameState.pgnSynced = true;
                        }
                    }
                    updateBoardUI();
                    updateMoveHistory();
                    updateCapturedUI();
                    updatePlayerIndicators();
                    updateGameStatus();
                    updateVariationUI();
                    if (engineRequested) {
                        if (!analysisState.enabled) {
                            setAnalysisEnabled(true);
                        }
                        if (analysisState.enabled) {
                            scheduleAnalysis(150);
                        }
                        showElement(analysisButtons);
                        showElement(analyzeEngineBtn);
                        showElement(analysisPanel);
                        showEngineVisuals();
                    } else {
                        setAnalysisEnabled(false, { hidePanel: false });
                        hideElement(analysisButtons);
                        hideElement(analyzeEngineBtn);
                        if (analysisPanel) showElement(analysisPanel);
                        hideEngineVisuals();
                    }
                    const redoHistoryTailClone = [...gameState.redoHistory];
                    pendingAnalysisLoad = null;
                } else if (!engineRequested) {
                    setAnalysisEnabled(false, { hidePanel: false });
                    hideElement(analysisButtons);
                    showElement(analyzeEngineBtn);
                    if (analysisPanel) showElement(analysisPanel);
                    hideEngineVisuals();
                }
            }
            const completedHistory = {
                entries: [],
                loading: false,
                error: null,
            };

            const gameHistoryPanel = document.getElementById('gameHistoryPanel');
            const gameHistoryMeta = document.getElementById('gameHistoryMeta');
            const gameHistoryBody = document.getElementById('gameHistoryBody');
            const gameHistoryEmpty = document.getElementById('gameHistoryEmpty');
            const gameHistoryTableWrapper = document.getElementById('gameHistoryTableWrapper');
            const gameHistoryRefreshBtn = document.getElementById('gameHistoryRefresh');
            const gameHistoryClearBtn = document.getElementById('gameHistoryClear');

            function formatTimestamp(ts) {
                if (!ts) return '';
                try {
                    const date = new Date(ts);
                    if (Number.isNaN(date.getTime())) return '';
                    return date.toLocaleString();
                } catch (err) {
                    return '';
                }
            }

            function formatGameResult(entry) {
                if (!entry) return '';
                if (entry.result) return entry.result;
                if (entry.winner) return `${entry.winner} wins`;
                if (entry.reason) return entry.reason;
                return 'Completed';
            }

            function renderCompletedGames() {
                if (!gameHistoryPanel) return;
                const entries = Array.isArray(completedHistory.entries) ? completedHistory.entries : [];

                if (gameHistoryMeta) {
                    if (completedHistory.loading) {
                        gameHistoryMeta.textContent = 'Loading';
                    } else if (completedHistory.error) {
                        gameHistoryMeta.textContent = 'Unable to load history';
                    } else if (entries.length) {
                        gameHistoryMeta.textContent = `${entries.length} game${entries.length === 1 ? '' : 's'}`;
                    } else {
                        gameHistoryMeta.textContent = 'No completed games';
                    }
                }

                if (!gameHistoryBody || !gameHistoryEmpty || !gameHistoryTableWrapper) return;
                gameHistoryBody.innerHTML = '';

                if (!entries.length) {
                    showElement(gameHistoryEmpty);
                    hideElement(gameHistoryTableWrapper);
                    return;
                }

                hideElement(gameHistoryEmpty);
                showElement(gameHistoryTableWrapper);

                entries.forEach((entry) => {
                    const tr = document.createElement('tr');

                    const finishedCell = document.createElement('td');
                    finishedCell.textContent = formatTimestamp(entry.finishedAt || entry.completedAt);
                    tr.appendChild(finishedCell);

                    const resultCell = document.createElement('td');
                    resultCell.textContent = formatGameResult(entry);
                    tr.appendChild(resultCell);

                    const winnerCell = document.createElement('td');
                    winnerCell.textContent = entry.winner || '';
                    tr.appendChild(winnerCell);

                    const movesCell = document.createElement('td');
                    const moveCount = Array.isArray(entry.moves) ? entry.moves.length : 0;
                    movesCell.textContent = moveCount ? `${moveCount} ply` : '';
                    tr.appendChild(movesCell);

                    const playersCell = document.createElement('td');
                    if (Array.isArray(entry.players) && entry.players.length) {
                        playersCell.textContent = entry.players.map((p) => p?.name || p?.id || 'Player').join(' vs ');
                    } else {
                        playersCell.textContent = '';
                    }
                    tr.appendChild(playersCell);

                    const replayCell = document.createElement('td');
                    if (entry.moves && entry.moves.length) {
                        const btn = document.createElement('button');
                        btn.textContent = 'Replay';
                        btn.addEventListener('click', () => replayCompletedGame(entry));
                        replayCell.appendChild(btn);
                    } else {
                        replayCell.textContent = '';
                    }
                    tr.appendChild(replayCell);

                    gameHistoryBody.appendChild(tr);
                });
            }

            async function fetchCompletedGames() {
                if (!gameHistoryPanel) return;
                if (completedHistory.loading) return;
                completedHistory.loading = true;
                completedHistory.error = null;
                try {
                    if (authState.currentUser) {
                        const { games } = await fetchUserHistory();
                        completedHistory.entries = games.map((entry) => ({
                            id: entry.id,
                            finishedAt: entry.finishedAt,
                            result: entry.result,
                            reason: entry.reason,
                            winner: entry.winner,
                            players: entry.players,
                            moves: entry.moves,
                        }));
                    } else {
                        completedHistory.entries = [];
                    }
                    gameState.completedHistoryLoaded = true;
                } catch (err) {
                    completedHistory.error = err;
                    console.warn('Unable to load completed games history', err);
                } finally {
                    completedHistory.loading = false;
                    renderCompletedGames();
                }
            }

            async function clearCompletedGamesHistory() {
                if (!authState.currentUser) {
                    alert('Sign in to manage history.');
                    return;
                }
                completedHistory.entries = [];
                renderCompletedGames();
                appendHistoryEntry({ type: 'game', payload: { clear: true } }).catch((err) => {
                    console.warn('Unable to clear remote history', err);
                });
            }

            function ensureGameHistoryVisible() {
                if (!gameHistoryPanel) return;
                showElement(gameHistoryPanel);
                if (!gameState.completedHistoryLoaded && !completedHistory.loading) {
                    fetchCompletedGames();
                }
            }

            function replayCompletedGame(entry) {
                if (!entry || !Array.isArray(entry.moves) || !entry.moves.length) {
                    alert('Replay data unavailable for this game.');
                    return;
                }
                window.location.hash = '#analysis';
                setTimeout(() => {
                    const sanMoves = entry.moves.map((move) => move.notation || move.san || move);
                    const pgnText = Array.isArray(sanMoves) ? sanMoves.join(' ') : '';
                    const pgnArea = document.getElementById('pgnInput');
                    if (pgnArea) {
                        pgnArea.value = pgnText;
                        pgnLoad(pgnText);
                        gameState.history = [];
                        gameState.redoHistory = [];
                        playSANSequence(gameState.pgnMoves);
                        gameState.pgnIndex = gameState.pgnMoves.length;
                        gameState.pgnSynced = true;
                    }
                }, 150);
            }

            if (gameHistoryRefreshBtn) {
                gameHistoryRefreshBtn.addEventListener('click', fetchCompletedGames);
            }
            if (gameHistoryClearBtn) {
                gameHistoryClearBtn.addEventListener('click', async () => {
                    const confirmed = await showConfirmationDialog({
                        title: 'Clear Completed Games',
                        message: 'This will erase all recorded completed games. Continue?',
                        confirmLabel: 'Clear History',
                        cancelLabel: 'Cancel',
                    });
                    if (confirmed) {
                        clearCompletedGamesHistory();
                    }
                });
            }

            const aiRegistry = {
                'stockfish-local': {
                    id: 'stockfish-local',
                    name: 'Stockfish (Local)',
                    description: 'Strong classical engine using your local Stockfish binary.',
                    tags: ['engine', 'strong'],
                    moveDelayMs: 350,
                    fallbackId: 'random-baseline',
                    skillLevel: 10,
                    enabled: !!backendBase,
                    async getMove() {
                        try {
                            const fen = generateFEN();
                            const endpoint = `${backendBase.replace(/\/$/, '')}/engines/stockfish/move`;
                            const payload = {
                                fen,
                                skillLevel: this.skillLevel ?? 10,
                                sideToMove: gameState.currentPlayer,
                            };
                            const res = await fetch(endpoint, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            if (!res.ok) {
                                throw new Error(`Stockfish responded ${res.status}`);
                            }
                            const data = await res.json();
                            const uci = data.bestMove || data.move || data.uci;
                            if (!uci) return null;
                            const coords = uciToCoords(uci.trim());
                            if (!coords) return null;
                            const { fr, fc, tr, tc, promotion } = coords;
                            return { fr, fc, tr, tc, promotion: promotion || 'q' };
                        } catch (err) {
                            console.warn('Stockfish move failed', err);
                            return null;
                        }
                    }
                },
                'random-baseline': {
                    id: 'random-baseline',
                    name: 'Random Baseline',
                    description: 'Chooses a random legal move. Great for testing.',
                    tags: ['casual', 'baseline'],
                    moveDelayMs: 150,
                    async getMove() {
                        const legal = listAllLegalMoves();
                        if (!legal || legal.length === 0) return null;
                        const choice = legal[Math.floor(Math.random() * legal.length)];
                        if (!choice) return null;
                        const [fr, fc, tr, tc] = choice;
                        const piece = gameState.board[fr]?.[fc];
                        let promotion = null;
                        if (piece && piece[1] === 'p' && (tr === 0 || tr === 7)) {
                            promotion = 'q';
                        }
                        return { fr, fc, tr, tc, promotion };
                    }
                }
            };

            const aiRegistryOrder = ['stockfish-local', 'random-baseline'];

            const aiModalState = {
                selectedOpponentId: null,
                lastFocused: null,
                returnHash: null,
            };

            let activeView = 'home';
            let lastNonComputerView = 'home';
            let pendingAnalysisLoad = null;

            function setActiveView(view) {
                activeView = view;
                if (view !== 'computer') {
                    lastNonComputerView = view;
                }
            }

            const ratingTrendState = {
                canvas: document.getElementById('puzzleRatingTrend'),
                empty: document.getElementById('puzzleRatingTrendEmpty'),
                ctx: null,
            };

            const analysisState = {
                enabled: false,
                pendingTimer: null,
                inProgress: false,
                needsRerun: false,
                lastRequestId: 0,
                lastEvaluatedFen: null,
                preferredMoveTime: 1200,
            };

            const engineEvalBar = document.getElementById('engineEvalBar');
            const engineEvalLabel = document.getElementById('engineEvalLabel');
            const engineEvalFill = document.getElementById('engineEvalFill');

            const evaluationGraphState = {
                panel: document.getElementById('evaluationGraphPanel'),
                canvas: document.getElementById('evaluationGraphCanvas'),
                empty: document.getElementById('evaluationGraphEmpty'),
                latest: document.getElementById('evaluationGraphLatest'),
                ctx: null,
                data: [],
            };

            const moveQualityState = {
                lastCp: null,
                lastMoveCount: 0,
                indicatorEl: null,
                lastQuality: null,
            };

            const moveQualityThresholds = {
                mistake: 100,
                blunder: 250,
            };

            function resetEvaluationGraph() {
                const { panel, canvas, empty, latest } = evaluationGraphState;
                evaluationGraphState.data = [];
                if (latest) latest.textContent = 'Last: ';
                if (empty) empty.classList.remove('hidden');
                if (canvas) {
                    canvas.style.display = 'none';
                    const ctx = evaluationGraphState.ctx;
                    if (ctx && canvas.width && canvas.height) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                }
                if (panel) panel.classList.add('hidden');
                moveQualityState.lastCp = null;
                moveQualityState.lastMoveCount = Array.isArray(gameState.moveHistory) ? gameState.moveHistory.length : 0;
                clearMoveQualityIndicator();
            }

            function clearMoveQualityIndicator() {
                if (moveQualityState.indicatorEl && moveQualityState.indicatorEl.parentElement) {
                    moveQualityState.indicatorEl.parentElement.removeChild(moveQualityState.indicatorEl);
                }
                moveQualityState.indicatorEl = null;
                moveQualityState.lastQuality = null;
            }

            function showMoveQualityIndicator(quality) {
                const lastMove = gameState.lastMove;
                if (!lastMove) return;
                const square = document.querySelector(`.square[data-row="${lastMove.toRow}"][data-col="${lastMove.toCol}"]`);
                if (!square) return;
                clearMoveQualityIndicator();
                const indicator = document.createElement('div');
                indicator.className = `move-quality-indicator ${quality}`;
                indicator.textContent = quality === 'blunder' ? '??' : '?';
                square.appendChild(indicator);
                moveQualityState.indicatorEl = indicator;
                moveQualityState.lastQuality = quality;
            }

            function stopAnalysisForGameOver() {
                if (analysisState.pendingTimer) {
                    clearTimeout(analysisState.pendingTimer);
                    analysisState.pendingTimer = null;
                }
                analysisState.needsRerun = false;
                analysisState.lastEvaluatedFen = null;
                analysisState.lastRequestId += 1;
            }

            function applyFinalEvaluation(winnerColor) {
                const normalizedWinner = winnerColor === 'black' ? 'black' : 'white';
                const mateSign = normalizedWinner === 'white' ? 1 : -1;
                const finalEvaluation = { type: 'mate', value: mateSign };
                updateEngineEvalBar({ evaluation: finalEvaluation });
                updateEvaluationGraph({ evaluation: finalEvaluation });
                clearMoveQualityIndicator();
            }

            function ensureEvaluationGraphContext() {
                if (!evaluationGraphState.canvas) return null;
                if (evaluationGraphState.ctx) return evaluationGraphState.ctx;
                const ctx = evaluationGraphState.canvas.getContext('2d');
                evaluationGraphState.ctx = ctx;
                return ctx;
            }

            function convertEvaluationToCentipawns(evaluation) {
                if (!evaluation) return null;
                const type = evaluation.type || evaluation.kind;
                if (type === 'mate') {
                    const val = Number(evaluation.value);
                    if (!Number.isFinite(val) || val === 0) return null;
                    const sign = val > 0 ? 1 : -1;
                    const distance = Math.min(50, Math.abs(val));
                    return sign * (2000 - distance * 20);
                }
                if (type === 'cp') {
                    const cp = Number(evaluation.value);
                    return Number.isFinite(cp) ? cp : null;
                }
                return null;
            }

            function renderEvaluationGraph() {
                const { canvas, data } = evaluationGraphState;
                if (!canvas || !data.length) return;
                const ctx = ensureEvaluationGraphContext();
                if (!ctx) return;

                const rect = canvas.getBoundingClientRect();
                const width = Math.max(1, Math.floor(rect.width));
                const height = Math.max(1, Math.floor(rect.height));
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                }

                ctx.save();
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(23, 32, 42, 0.85)';
                ctx.fillRect(0, 0, width, height);

                const values = data.map(point => point.cp);
                const maxAbs = values.reduce((acc, val) => Math.max(acc, Math.abs(val)), 0);
                const bound = Math.max(200, maxAbs + 80);
                const mapValue = (value) => {
                    const limited = Math.max(-bound, Math.min(bound, value));
                    return height - ((limited + bound) / (bound * 2)) * height;
                };

                const zeroY = mapValue(0);
                ctx.strokeStyle = 'rgba(236, 240, 241, 0.25)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(width, zeroY);
                ctx.stroke();
                ctx.setLineDash([]);

                if (data.length === 1) {
                    const x = width / 2;
                    const y = mapValue(data[0].cp);
                    ctx.strokeStyle = '#58d68d';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, height);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = '#58d68d';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    data.forEach((point, idx) => {
                        const x = (idx / (data.length - 1)) * (width - 1);
                        const y = mapValue(point.cp);
                        if (idx === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                }

                const lastPoint = data[data.length - 1];
                const lastX = data.length === 1 ? width / 2 : ((data.length - 1) / (data.length - 1)) * (width - 1);
                const lastY = mapValue(lastPoint.cp);
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function updateEvaluationGraphLatest(evaluation) {
                if (!evaluationGraphState.latest) return;
                const text = describeEvaluation(evaluation);
                evaluationGraphState.latest.textContent = `Last: ${text}`;
            }

            function updateEvaluationGraph({ evaluation } = {}) {
                if (!evaluation || !evaluationGraphState.panel) {
                    return;
                }
                if (!analysisState || !analysisState.enabled || activeView !== 'analysis-engine') {
                    return;
                }
                const cp = convertEvaluationToCentipawns(evaluation);
                updateEvaluationGraphLatest(evaluation);
                if (!Number.isFinite(cp)) {
                    return;
                }

                const moveCount = Array.isArray(gameState.moveHistory) ? gameState.moveHistory.length : 0;
                const previousMoveCount = moveQualityState.lastMoveCount;
                const previousCp = moveQualityState.lastCp;

                const ply = moveCount;
                evaluationGraphState.data.push({ ply, cp });
                if (evaluationGraphState.data.length > 150) {
                    evaluationGraphState.data.shift();
                }

                const { panel, canvas, empty } = evaluationGraphState;
                panel.classList.remove('hidden');
                if (canvas) canvas.style.display = 'block';
                if (empty) empty.classList.add('hidden');

                renderEvaluationGraph();

                if (analysisState.enabled && moveCount > previousMoveCount && Number.isFinite(previousCp)) {
                    const delta = cp - previousCp;
                    let quality = null;
                    if (delta <= -moveQualityThresholds.blunder) {
                        quality = 'blunder';
                    } else if (delta <= -moveQualityThresholds.mistake) {
                        quality = 'mistake';
                    }
                    if (quality) {
                        showMoveQualityIndicator(quality);
                    } else {
                        clearMoveQualityIndicator();
                    }
                } else if (analysisState.enabled && moveCount > previousMoveCount) {
                    clearMoveQualityIndicator();
                }

                moveQualityState.lastMoveCount = moveCount;
                moveQualityState.lastCp = cp;
            }

            function normalizeEvaluationForWhite(evaluation, sideToMove = 'white') {
                if (!evaluation || typeof evaluation !== 'object') return null;
                const normalized = { ...evaluation };
                const moverSign = sideToMove === 'black' ? -1 : 1;
                if (normalized.value != null) {
                    const numeric = Number(normalized.value);
                    if (Number.isFinite(numeric)) {
                        normalized.value = moverSign === 1 ? numeric : -numeric;
                    }
                }
                return normalized;
            }

            function updateEngineEvalBar({ evaluation } = {}) {
                if (!engineEvalBar || !engineEvalFill || !engineEvalLabel) return;
                if (!analysisState.enabled || !evaluation) {
                    engineEvalBar.classList.remove('visible');
                    engineEvalBar.setAttribute('aria-hidden', 'true');
                    engineEvalLabel.textContent = '';
                    engineEvalFill.style.height = '50%';
                    return;
                }

                const type = evaluation.type || evaluation.kind;
                let whitePercent;
                let labelText;

                if (type === 'mate') {
                    const mateValue = Number(evaluation.value);
                    const mateText = Number.isFinite(mateValue) ? `Mate in ${Math.abs(mateValue)}` : 'Mate';
                    labelText = mateText;
                    if (!Number.isFinite(mateValue)) {
                        whitePercent = 50;
                    } else if (mateValue < 0) {
                        whitePercent = 0;
                    } else {
                        whitePercent = 100;
                    }
                } else if (type === 'cp') {
                    const cp = Number(evaluation.value);
                    if (!Number.isFinite(cp)) {
                        labelText = '';
                        whitePercent = 50;
                    } else {
                        const capped = Math.max(-500, Math.min(500, cp));
                        whitePercent = 50 + (capped / 1000) * 100;
                        const score = (cp / 100).toFixed(2);
                        const prefix = cp > 0 ? '+' : '';
                        labelText = `${prefix}${score}`;
                    }
                } else {
                    whitePercent = 50;
                    labelText = '';
                }

                whitePercent = Math.max(0, Math.min(100, whitePercent));
                engineEvalFill.style.height = `${whitePercent}%`;
                engineEvalLabel.textContent = labelText;
                engineEvalLabel.style.bottom = `${whitePercent}%`;
                engineEvalBar.classList.add('visible');
                engineEvalBar.setAttribute('aria-hidden', 'false');
            }

            function updateAnalysisStatus(message) {
                const el = document.getElementById('analysisStatus');
                if (el) el.textContent = message;
            }

            function updateAnalysisScoreText(text) {
                const el = document.getElementById('analysisScore');
                if (el) el.textContent = text;
            }

            function updateAnalysisDepthText(text) {
                const el = document.getElementById('analysisDepth');
                if (el) el.textContent = text;
            }

            function updateAnalysisLines(lines) {
                const container = document.getElementById('analysisLines');
                if (!container) return;
                container.innerHTML = '';
                const entries = Array.isArray(lines) ? lines.slice(0, 3) : [];
                if (!entries.length) {
                    const placeholder = document.createElement('div');
                    placeholder.textContent = 'No principal variation available.';
                    placeholder.style.color = '#bdc3c7';
                    placeholder.style.fontSize = '0.95rem';
                    container.appendChild(placeholder);
                    return;
                }
                entries.forEach((line, idx) => {
                    const wrapper = document.createElement('div');
                    wrapper.style.display = 'flex';
                    wrapper.style.flexDirection = 'column';
                    wrapper.style.gap = '0.2rem';
                    wrapper.style.background = 'rgba(52, 73, 94, 0.45)';
                    wrapper.style.borderRadius = '6px';
                    wrapper.style.padding = '0.45rem 0.6rem';

                    const header = document.createElement('div');
                    header.style.display = 'flex';
                    header.style.justifyContent = 'space-between';
                    header.style.alignItems = 'center';
                    header.style.fontSize = '0.9rem';
                    header.style.color = '#f1c40f';
                    const lineIdx = line && typeof line.index === 'number' ? line.index : (idx + 1);
                    header.textContent = `Line ${lineIdx}`;

                    const scoreText = document.createElement('div');
                    scoreText.style.fontSize = '0.95rem';
                    scoreText.style.color = '#ecf0f1';
                    const evalText = describeEvaluation(line?.evaluation) || '';
                    const depthText = line?.depth != null ? line.depth : '';
                    scoreText.textContent = `Score: ${evalText} | Depth: ${depthText}`;

                    const pvText = document.createElement('div');
                    pvText.style.fontFamily = "'Consolas','Courier New',monospace";
                    pvText.style.color = '#d6eaf8';
                    pvText.style.whiteSpace = 'normal';
                    const pvMoves = Array.isArray(line?.pv) && line.pv.length ? line.pv.join(' ') : '';
                    pvText.textContent = `PV: ${pvMoves}`;

                    wrapper.appendChild(header);
                    wrapper.appendChild(scoreText);
                    wrapper.appendChild(pvText);
                    container.appendChild(wrapper);
                });
            }

            function resetAnalysisPanel() {
                updateAnalysisStatus('Idle');
                updateAnalysisScoreText('Score: ');
                updateAnalysisDepthText('Depth: ');
                updateAnalysisLines([]);
                updateEngineEvalBar();
                resetEvaluationGraph();
            }

            function describeEvaluation(evaluation) {
                if (!evaluation) return '';
                const type = evaluation.type || evaluation.kind;
                if (type === 'mate') {
                    const val = Number(evaluation.value);
                    if (!Number.isFinite(val) || val === 0) return 'Mate';
                    return `Mate in ${Math.abs(val)}`;
                }
                if (type === 'cp') {
                    const cp = Number(evaluation.value);
                    if (!Number.isFinite(cp)) return '';
                    const score = (cp / 100).toFixed(2);
                    const prefix = cp > 0 ? '+' : '';
                    return `${prefix}${score} (cp ${cp})`;
                }
                return '';
            }

            function setAnalysisEnabled(enabled, { hidePanel = false } = {}) {
                const panel = document.getElementById('analysisPanel');
                const toggleBtn = document.getElementById('analysisToggle');

                if (analysisState.pendingTimer) {
                    clearTimeout(analysisState.pendingTimer);
                    analysisState.pendingTimer = null;
                }

                if (!enabled) {
                    analysisState.enabled = false;
                    analysisState.inProgress = false;
                    analysisState.needsRerun = false;
                    analysisState.lastEvaluatedFen = null;
                    resetAnalysisPanel();
                    updateEngineEvalBar();
                    resetEvaluationGraph();
                    if (toggleBtn) toggleBtn.textContent = 'Start';
                    if (hidePanel && panel) panel.classList.add('hidden');
                    if (!hidePanel && panel) panel.classList.remove('hidden');
                    toggleEngineAnalysisSections(false);
                    hideEngineVisuals();
                    return;
                }

                analysisState.enabled = true;
                analysisState.lastEvaluatedFen = null;
                resetEvaluationGraph();
                if (panel) panel.classList.remove('hidden');
                if (toggleBtn) toggleBtn.textContent = 'Disable';
                toggleEngineAnalysisSections(true);
                updateAnalysisStatus('Queued');
                scheduleAnalysis(150);
            }

            function scheduleAnalysis(delay = 350) {
                if (!analysisState.enabled) return;
                if (gameState.gameOver) return;
                if (analysisState.inProgress) {
                    analysisState.needsRerun = true;
                    return;
                }
                if (analysisState.pendingTimer) {
                    clearTimeout(analysisState.pendingTimer);
                }
                analysisState.pendingTimer = setTimeout(() => {
                    analysisState.pendingTimer = null;
                    runAnalysis();
                }, Math.max(0, delay));
            }

            async function runAnalysis() {
                if (!analysisState.enabled) return;
                if (gameState.gameOver) return;
                if (analysisState.inProgress) {
                    analysisState.needsRerun = true;
                    return;
                }
                if (!gameState.board || !gameState.board.length || gameState.pendingMove) {
                    resetAnalysisPanel();
                    return;
                }
                const fen = generateFEN();
                if (!fen) {
                    updateAnalysisStatus('Unable to generate FEN');
                    return;
                }
                analysisState.inProgress = true;
                analysisState.needsRerun = false;
                const requestId = ++analysisState.lastRequestId;
                updateAnalysisStatus('Evaluating');
                try {
                    const endpoint = `${backendBase.replace(/\/$/, '')}/engines/stockfish/move`;
                    const res = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            fen,
                            movetime: analysisState.preferredMoveTime,
                            skillLevel: 20,
                            multiPv: 3,
                        })
                    });
                    if (!res.ok) {
                        throw new Error(`Engine responded ${res.status}`);
                    }
                    const data = await res.json();
                    if (!analysisState.enabled || requestId !== analysisState.lastRequestId) {
                        return;
                    }
                    analysisState.lastEvaluatedFen = fen;
                    const primaryLine = Array.isArray(data.lines) && data.lines.length ? data.lines[0] : null;
                    const bestMove = primaryLine?.bestMove || data.bestMove || data.move || data.uci || null;
                    const normalizedPrimaryEval = normalizeEvaluationForWhite(primaryLine?.evaluation || data.evaluation, gameState.currentPlayer);
                    const evaluationText = describeEvaluation(normalizedPrimaryEval);
                    const scoreLine = bestMove ? `Score: ${evaluationText} (Best: ${bestMove})` : `Score: ${evaluationText}`;
                    updateAnalysisScoreText(scoreLine);
                    const depthValue = primaryLine?.depth != null ? primaryLine.depth : (data.depth != null ? data.depth : '');
                    updateAnalysisDepthText(`Depth: ${depthValue}`);
                    const normalizedLines = Array.isArray(data.lines)
                        ? data.lines.map(line => ({
                            ...line,
                            evaluation: normalizeEvaluationForWhite(line?.evaluation, gameState.currentPlayer),
                        }))
                        : [];
                    updateAnalysisLines(normalizedLines);
                    updateEngineEvalBar({ evaluation: normalizedPrimaryEval });
                    updateEvaluationGraph({ evaluation: normalizedPrimaryEval });
                    updateAnalysisStatus('Ready');
                } catch (err) {
                    if (analysisState.enabled) {
                        updateAnalysisStatus(`Error: ${err.message}`);
                        updateAnalysisScoreText('Score: ');
                        updateAnalysisDepthText('Depth: ');
                        updateAnalysisLines([]);
                        updateEngineEvalBar();
                    }
                } finally {
                    analysisState.inProgress = false;
                    if (analysisState.enabled && analysisState.needsRerun) {
                        analysisState.needsRerun = false;
                        scheduleAnalysis(200);
                    }
                }
            }

            function onAnalysisPositionChanged() {
                if (!analysisState.enabled) return;
                if (gameState.gameOver) return;
                if (!gameState.board || !gameState.board.length || gameState.pendingMove) return;
                scheduleAnalysis(300);
            }

            let puzzleAudioContext = null;

            function normalizeAttemptRecord(raw, fallbackNow) {
                if (!raw || (raw.id == null && raw.puzzleId == null)) return null;
                const now = Number.isFinite(fallbackNow) ? fallbackNow : Date.now();
                const baseTimestamp = Number.isFinite(raw.timestamp)
                    ? raw.timestamp
                    : (Number.isFinite(raw.completedAt) ? raw.completedAt : now);
                const mistakes = Array.isArray(raw.mistakes) ? raw.mistakes.map(item => ({ ...item })).slice(0, 20) : [];
                const puzzleId = raw.puzzleId != null ? raw.puzzleId : raw.id;
                const ratingDelta = Number.isFinite(raw.delta)
                    ? raw.delta
                    : (Number.isFinite(raw.ratingDelta) ? raw.ratingDelta : 0);
                const ratingAfter = Number.isFinite(raw.ratingAfter)
                    ? raw.ratingAfter
                    : (Number.isFinite(raw.rating_after) ? raw.rating_after : undefined);
                const streakValue = Number.isFinite(raw.streak)
                    ? raw.streak
                    : (Number.isFinite(raw.streakAfter) ? raw.streakAfter : 0);
                const successValue = raw.success != null ? !!raw.success : !!raw.solved;
                return {
                    id: String(puzzleId),
                    puzzleId: String(puzzleId),
                    success: successValue,
                    timestamp: baseTimestamp,
                    completedAt: Number.isFinite(raw.completedAt) ? raw.completedAt : baseTimestamp,
                    streak: streakValue,
                    delta: ratingDelta,
                    tookHint: !!raw.tookHint,
                    mistakes,
                    reason: raw.reason || (successValue ? 'solved' : 'failed'),
                    ratingAfter: ratingAfter,
                };
            }

            function normalizeReviewEntry(raw) {
                if (!raw || !raw.id) return null;
                return {
                    id: String(raw.id),
                    mistakes: Array.isArray(raw.mistakes) ? raw.mistakes.map(item => ({ ...item })).slice(0, 20) : [],
                    completedAt: Number.isFinite(raw.completedAt) ? raw.completedAt : Date.now(),
                    tookHint: !!raw.tookHint,
                };
            }

            const historyOverlay = document.getElementById('historyOverlay');
            const historyMetaEl = document.getElementById('historyMeta');
            const historyEmptyEl = document.getElementById('historyEmpty');
            const historyWrapperEl = document.getElementById('historyTableWrapper');
            const historyTableBody = document.getElementById('historyTableBody');
            const historyCloseBtn = document.getElementById('historyCloseBtn');
            const historyCloseFooterBtn = document.getElementById('historyCloseFooterBtn');
            const historyRefreshBtn = document.getElementById('historyRefreshBtn');

            restoreAuthState();
            updateAuthUI();
            await attemptSessionRestore();
            updatePuzzleStreakDisplay();
            updatePlayerRatingDisplay();
            updateReviewButtonState();
            updateRatingTrendChart();

            function clearPuzzleHistory({ keepStreak = false } = {}) {
                if (!authState.currentUser) {
                    alert('Sign in to manage puzzle history.');
                    return;
                }
                gameState.attemptHistory = [];
                gameState.solvedIds = new Set();
                gameState.reviewQueue = [];
                puzzleState.mistakeMoves = [];
                puzzleState.usedHint = false;
                puzzleState.madeMistake = false;
                puzzleState.ratingSettled = false;
                puzzleState.lastDelta = 0;
                puzzleState.streak = keepStreak ? puzzleState.streak : 0;
                puzzleState.playerRating = keepStreak ? puzzleState.playerRating : 1500;
                puzzleState.ratingHistory = [];
                refreshPuzzleHistoryView();
                updatePuzzleStreakDisplay();
                updatePlayerRatingDisplay();
                updateReviewButtonState();
                updateRatingTrendChart();
                appendHistoryEntry({ type: 'puzzle', payload: { clear: true, rating: puzzleState.playerRating, streak: puzzleState.streak } }).catch((err) => {
                    console.warn('Unable to clear puzzle history remotely', err);
                });
            }

            const confirmOverlay = document.getElementById('confirmOverlay');
            const confirmTitleEl = document.getElementById('confirmTitle');
            const confirmMessageEl = document.getElementById('confirmMessage');
            const confirmCancelBtn = document.getElementById('confirmCancelBtn');
            const confirmConfirmBtn = document.getElementById('confirmConfirmBtn');
            let confirmResolve = null;

            function formatHistoryDate(timestamp) {
                if (!Number.isFinite(timestamp)) return '';
                try {
                    const date = new Date(timestamp);
                    if (Number.isNaN(date.getTime())) return '';
                    return date.toLocaleString(undefined, {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                    });
                } catch (err) {
                    return '';
                }
            }

            function refreshPuzzleHistoryView() {
                if (!historyMetaEl || !historyEmptyEl || !historyWrapperEl || !historyTableBody) return;
                const attempts = Array.isArray(gameState.attemptHistory) ? gameState.attemptHistory.slice() : [];
                attempts.sort((a, b) => {
                    const aTime = Number.isFinite(a?.completedAt) ? a.completedAt : (Number.isFinite(a?.timestamp) ? a.timestamp : 0);
                    const bTime = Number.isFinite(b?.completedAt) ? b.completedAt : (Number.isFinite(b?.timestamp) ? b.timestamp : 0);
                    return bTime - aTime;
                });
                const total = attempts.length;
                historyMetaEl.textContent = total ? `${total} attempt${total === 1 ? '' : 's'} recorded` : 'No attempts recorded yet';
                historyTableBody.innerHTML = '';
                if (!total) {
                    historyEmptyEl.classList.remove('hidden');
                    historyEmptyEl.hidden = false;
                    historyWrapperEl.classList.add('hidden');
                    historyWrapperEl.hidden = true;
                    return;
                }
                historyEmptyEl.classList.add('hidden');
                historyEmptyEl.hidden = true;
                historyWrapperEl.classList.remove('hidden');
                historyWrapperEl.hidden = false;
                attempts.forEach((attempt) => {
                    const tr = document.createElement('tr');
                    const dateCell = document.createElement('td');
                    dateCell.textContent = formatHistoryDate(Number.isFinite(attempt.completedAt) ? attempt.completedAt : attempt.timestamp);
                    tr.appendChild(dateCell);

                    const idCell = document.createElement('td');
                    idCell.textContent = attempt.id || '';
                    tr.appendChild(idCell);

                    const resultCell = document.createElement('td');
                    const success = !!attempt.success;
                    resultCell.textContent = success ? 'Solved' : (attempt.reason ? attempt.reason.replace(/[-_]/g, ' ') : 'Failed');
                    resultCell.className = success ? 'history-result-success' : 'history-result-fail';
                    tr.appendChild(resultCell);

                    const deltaCell = document.createElement('td');
                    deltaCell.textContent = Number.isFinite(attempt.delta) ? formatRatingDelta(attempt.delta) : '';
                    tr.appendChild(deltaCell);

                    const streakCell = document.createElement('td');
                    streakCell.textContent = Number.isFinite(attempt.streak) ? `${attempt.streak}` : '';
                    tr.appendChild(streakCell);

                    const mistakesCell = document.createElement('td');
                    const mistakeCount = Array.isArray(attempt.mistakes) ? attempt.mistakes.length : 0;
                    mistakesCell.textContent = mistakeCount ? `${mistakeCount}` : '';
                    tr.appendChild(mistakesCell);

                    const hintCell = document.createElement('td');
                    hintCell.textContent = attempt.tookHint ? 'Yes' : 'No';
                    tr.appendChild(hintCell);

                    const reviewCell = document.createElement('td');
                    if (attempt.id) {
                        const viewBtn = document.createElement('button');
                        viewBtn.type = 'button';
                        viewBtn.textContent = 'Load';
                        viewBtn.dataset.puzzleId = attempt.id;
                        viewBtn.dataset.historyAction = 'load';
                        viewBtn.style.minWidth = '90px';
                        reviewCell.appendChild(viewBtn);
                    } else {
                        reviewCell.textContent = '';
                    }
                    tr.appendChild(reviewCell);

                    historyTableBody.appendChild(tr);
                });
            }

            function openPuzzleHistory() {
                if (!historyOverlay) return;
                refreshPuzzleHistoryView();
                historyOverlay.classList.remove('hidden');
                historyOverlay.classList.add('visible');
                historyOverlay.setAttribute('aria-hidden', 'false');
                if (historyCloseBtn) historyCloseBtn.focus({ preventScroll: true });
            }

            function closePuzzleHistory() {
                if (!historyOverlay) return;
                historyOverlay.classList.add('hidden');
                historyOverlay.classList.remove('visible');
                historyOverlay.setAttribute('aria-hidden', 'true');
            }

            function hideConfirmationDialog() {
                if (confirmOverlay) {
                    confirmOverlay.classList.add('hidden');
                    confirmOverlay.classList.remove('visible');
                    confirmOverlay.setAttribute('aria-hidden', 'true');
                }
                confirmResolve = null;
            }

            function showConfirmationDialog({ title, message, confirmLabel = 'Confirm', cancelLabel = 'Cancel' }) {
                return new Promise(resolve => {
                    if (!confirmOverlay) {
                        resolve(false);
                        return;
                    }
                    confirmResolve = resolve;
                    confirmTitleEl.textContent = title || 'Confirm Action';
                    confirmMessageEl.textContent = message || 'Are you sure?';
                    confirmCancelBtn.textContent = cancelLabel;
                    confirmConfirmBtn.textContent = confirmLabel;
                    confirmOverlay.classList.remove('hidden');
                    confirmOverlay.classList.add('visible');
                    confirmOverlay.setAttribute('aria-hidden', 'false');
                    confirmConfirmBtn.focus({ preventScroll: true });
                });
            }

            if (confirmCancelBtn) {
                confirmCancelBtn.addEventListener('click', () => {
                    if (confirmResolve) confirmResolve(false);
                    hideConfirmationDialog();
                });
            }

            if (confirmConfirmBtn) {
                confirmConfirmBtn.addEventListener('click', () => {
                    if (confirmResolve) confirmResolve(true);
                    hideConfirmationDialog();
                });
            }

            if (confirmOverlay) {
                confirmOverlay.addEventListener('click', (event) => {
                    if (event.target === confirmOverlay) {
                        if (confirmResolve) confirmResolve(false);
                        hideConfirmationDialog();
                    }
                });
            }

            document.addEventListener('keydown', (event) => {
                if (event.key !== 'Escape') return;
                if (confirmOverlay && confirmOverlay.classList.contains('visible')) {
                    if (confirmResolve) confirmResolve(false);
                    hideConfirmationDialog();
                    return;
                }
                if (historyOverlay && historyOverlay.classList.contains('visible')) {
                    closePuzzleHistory();
                }
            });

            function setPuzzleStatus(message, isError = false) {
                const status = document.getElementById('puzzleStatus');
                if (status) {
                    status.textContent = message;
                    status.style.color = isError ? '#e74c3c' : '#ecf0f1';
                }
                const floating = document.getElementById('puzzleStatusFloating');
                if (floating) {
                    floating.textContent = message;
                    floating.classList.toggle('is-error', !!isError);
                }
            }

            function updatePuzzleStreakDisplay() {
                const streakEl = document.getElementById('puzzleStreak');
                if (streakEl) streakEl.textContent = `${puzzleState.streak}`;
            }

            function updateReviewButtonState() {
                const reviewBtn = document.getElementById('puzzleReview');
                if (!reviewBtn) return;
                const hasQueue = Array.isArray(gameState.reviewQueue) && gameState.reviewQueue.length > 0;
                reviewBtn.disabled = !hasQueue;
                reviewBtn.textContent = hasQueue ? `Review Mistakes (${gameState.reviewQueue.length})` : 'Review Mistakes';
            }

            function queuePuzzleForReview(entry) {
                if (!entry || !entry.id) return;
                const existingIndex = gameState.reviewQueue.findIndex(item => item.id === entry.id);
                if (existingIndex >= 0) {
                    gameState.reviewQueue.splice(existingIndex, 1, entry);
                } else {
                    gameState.reviewQueue.push(entry);
                }
                updateReviewButtonState();
            }

            function finalizeCurrentPuzzleAttempt({ success = false, reason, skipQueue = false } = {}) {
                if (!puzzleState.currentPuzzleId || puzzleState.attemptRecorded) return;
                const inReview = !!puzzleState.reviewMode;
                const idKey = String(puzzleState.currentPuzzleId || '');
                const wasSolvedBefore = gameState.solvedIds.has(idKey);
                let outcomeDelta = puzzleState.lastDelta;
                if (!puzzleState.ratingSettled) {
                    if (inReview || wasSolvedBefore) {
                        puzzleState.ratingSettled = true;
                        puzzleState.lastDelta = 0;
                        outcomeDelta = 0;
                    } else {
                        const score = success ? 1 : 0;
                        outcomeDelta = settlePuzzleRating(score);
                    }
                }
                recordPuzzleAttempt({
                    success,
                    delta: outcomeDelta,
                    tookHint: puzzleState.usedHint,
                    mistakeMoves: puzzleState.mistakeMoves,
                    reason: reason || (inReview ? (success ? 'review-completed' : 'review-abandoned') : (success ? 'completed' : 'abandoned')),
                    skipQueue,
                });
            }

            function dequeueNextReviewPuzzle() {
                if (!Array.isArray(gameState.reviewQueue) || !gameState.reviewQueue.length) return null;
                const next = gameState.reviewQueue.shift();
                updateReviewButtonState();
                return next || null;
            }

            function formatRatingDelta(delta) {
                if (typeof delta !== 'number') return '';
                if (delta > 0) return `+${delta}`;
                if (delta < 0) return `${delta}`;
                return '0';
            }

            function updatePlayerRatingDisplay() {
                const ratingEl = document.getElementById('playerPuzzleRating');
                if (ratingEl) {
                    ratingEl.textContent = `${Math.round(puzzleState.playerRating)}`;
                }
                const deltaEl = document.getElementById('playerPuzzleDelta');
                if (deltaEl) {
                    if (puzzleState.ratingSettled) {
                        const text = formatRatingDelta(puzzleState.lastDelta);
                        deltaEl.textContent = text;
                        if (puzzleState.lastDelta > 0) deltaEl.style.color = '#58d68d';
                        else if (puzzleState.lastDelta < 0) deltaEl.style.color = '#e74c3c';
                        else deltaEl.style.color = '#ecf0f1';
                    } else {
                        deltaEl.textContent = '';
                        deltaEl.style.color = '#ecf0f1';
                    }
                }
            }

            function settlePuzzleRating(score) {
                if (puzzleState.ratingSettled) return puzzleState.lastDelta;
                const puzzleRating = (puzzleState.lastPuzzle && typeof puzzleState.lastPuzzle.rating === 'number')
                    ? puzzleState.lastPuzzle.rating
                    : 1500;
                const expected = 1 / (1 + Math.pow(10, (puzzleRating - puzzleState.playerRating) / 400));
                const kFactor = 24;
                const rawDelta = Math.round(kFactor * (score - expected));
                puzzleState.playerRating = Math.max(100, Math.round(puzzleState.playerRating + rawDelta));
                puzzleState.lastDelta = rawDelta;
                puzzleState.ratingSettled = true;
                updatePlayerRatingDisplay();
                return rawDelta;
            }

            function nextRatingWindowSize(previous) {
                const tiers = [100, 200, 300, 450, 600, 800];
                if (!Number.isFinite(previous) || previous < 0) return tiers[0];
                for (let i = 0; i < tiers.length; i += 1) {
                    if (previous < tiers[i]) return tiers[i];
                }
                return previous + 250;
            }

            function hidePuzzleSuccess() {
                const modal = document.getElementById('puzzleSuccessModal');
                if (modal) modal.classList.add('hidden');
            }

            function playPuzzleSuccessSound() {
                try {
                    if (!puzzleAudioContext) {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (!AudioContextClass) return;
                        puzzleAudioContext = new AudioContextClass();
                    }
                    if (puzzleAudioContext.state === 'suspended') {
                        puzzleAudioContext.resume().catch(() => {});
                    }
                    const ctx = puzzleAudioContext;
                    const now = ctx.currentTime;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(880, now);
                    gain.gain.setValueAtTime(0.0001, now);
                    gain.gain.exponentialRampToValueAtTime(0.25, now + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now);
                    osc.stop(now + 0.55);
                } catch (err) {
                    console.warn('Unable to play puzzle success sound', err);
                }
            }

            function showPuzzleSuccess() {
                const wasActive = puzzleState.active;
                puzzleState.active = false;
                const idKey = String(puzzleState.currentPuzzleId || '');
                const wasSolvedBefore = gameState.solvedIds.has(idKey);
                if (wasActive && !puzzleState.missedBeforeSuccess) {
                    puzzleState.streak = Math.max(0, puzzleState.streak + 1);
                    updatePuzzleStreakDisplay();
                }
                let delta = puzzleState.lastDelta;
                if (!puzzleState.ratingSettled) {
                    if (wasSolvedBefore) {
                        puzzleState.ratingSettled = true;
                        puzzleState.lastDelta = 0;
                        delta = 0;
                    } else {
                        const finalScore = puzzleState.madeMistake ? 0 : 1;
                        delta = settlePuzzleRating(finalScore);
                    }
                }
                const deltaText = formatRatingDelta(delta);
                const statusSuffix = puzzleState.ratingSettled ? ` ( ${deltaText} ELO)` : '';
                setPuzzleStatus(`Puzzle solved! ${statusSuffix}`);
                recordPuzzleAttempt({ success: true, delta, tookHint: puzzleState.usedHint, mistakeMoves: puzzleState.mistakeMoves });
                const modal = document.getElementById('puzzleSuccessModal');
                if (modal) {
                    modal.classList.remove('hidden');
                    const focusTarget = document.getElementById('puzzlePlayAgain');
                    if (focusTarget) {
                        setTimeout(() => focusTarget.focus({ preventScroll: true }), 50);
                    }
                    const body = document.getElementById('puzzleSuccessBody');
                    if (body) {
                        const ratingLine = `Your puzzle rating: <strong>${Math.round(puzzleState.playerRating)}</strong>`;
                        const deltaLine = `Rating change: <strong>${deltaText} ELO</strong>`;
                        body.innerHTML = `You solved the puzzle! Current streak: <strong>${puzzleState.streak}</strong><br>${ratingLine}<br>${deltaLine}`;
                    }
                }
                playPuzzleSuccessSound();
            }

            function recordPuzzleAttempt({ success, delta = 0, tookHint = false, mistakeMoves = [], reason, skipQueue = false } = {}) {
                if (!puzzleState.currentPuzzleId) return;
                if (puzzleState.attemptRecorded) return;
                const now = Date.now();
                const attempt = {
                    id: puzzleState.currentPuzzleId,
                    success: !!success,
                    timestamp: puzzleState.startTimestamp || now,
                    completedAt: now,
                    streak: puzzleState.streak,
                    delta,
                    tookHint: !!tookHint,
                    mistakes: Array.isArray(mistakeMoves) ? mistakeMoves.slice(0, 20) : [],
                    reason: reason || (success ? 'solved' : 'failed'),
                    ratingAfter: Number.isFinite(puzzleState.playerRating) ? Math.round(puzzleState.playerRating) : undefined,
                };
                gameState.attemptHistory.push(attempt);
                if (gameState.attemptHistory.length > 300) {
                    gameState.attemptHistory.splice(0, gameState.attemptHistory.length - 300);
                }
                if (attempt.success) {
                    gameState.solvedIds.add(attempt.id);
                    gameState.reviewQueue = gameState.reviewQueue.filter(item => item.id !== attempt.id);
                    if (attempt.mistakes.length) {
                        queuePuzzleForReview({
                            id: attempt.id,
                            mistakes: attempt.mistakes,
                            completedAt: attempt.completedAt,
                            tookHint: attempt.tookHint,
                        });
                    }
                    puzzleState.reviewMode = false;
                    puzzleState.reviewActiveEntry = null;
                } else if (!skipQueue) {
                    queuePuzzleForReview({
                        id: attempt.id,
                        mistakes: attempt.mistakes,
                        completedAt: attempt.completedAt,
                        tookHint: attempt.tookHint,
                    });
                    puzzleState.reviewMode = false;
                    puzzleState.reviewActiveEntry = null;
                }
                puzzleState.attemptRecorded = true;
                puzzleState.active = false;
                puzzleState.mistakeMoves = [];
                puzzleState.usedHint = false;
                puzzleState.missedBeforeSuccess = false;
                if (Number.isFinite(attempt.ratingAfter)) {
                    puzzleState.ratingHistory.push({ rating: attempt.ratingAfter, timestamp: attempt.completedAt });
                    if (puzzleState.ratingHistory.length > 500) {
                        puzzleState.ratingHistory = puzzleState.ratingHistory.slice(-500);
                    }
                    updateRatingTrendChart();
                }
                syncPuzzleAttemptWithBackend(attempt).catch((err) => {
                    console.warn('Unable to persist puzzle attempt', err);
                });
                updateReviewButtonState();
            }

            function updatePuzzleDetails(puzzle, { reviewEntry = null } = {}) {
                const details = document.getElementById('puzzleDetails');
                if (!details) return;
                puzzleState.lastPuzzle = puzzle;
                puzzleState.solution = (puzzle.moves || []).slice();
                puzzleState.active = !!(puzzle.moves && puzzle.moves.length);
                puzzleState.autoPlaying = false;
                puzzleState.ratingSettled = false;
                puzzleState.madeMistake = false;
                puzzleState.lastDelta = 0;
                puzzleState.currentPuzzleId = puzzle.id || null;
                puzzleState.startTimestamp = Date.now();
                puzzleState.mistakeMoves = [];
                puzzleState.attemptRecorded = false;
                gameState.mistakeRecordedForCurrent = false;
                puzzleState.usedHint = false;
                puzzleState.missedBeforeSuccess = false;
                if (puzzleState.reviewMode) {
                    puzzleState.streak = Math.max(0, puzzleState.streak);
                }
                hidePuzzleSuccess();
                removeHintHighlights();
                updatePlayerRatingDisplay();

                const idEl = document.getElementById('puzzleId');
                const ratingEl = document.getElementById('puzzleRating');
                const popularityEl = document.getElementById('puzzlePopularity');
                const fenEl = document.getElementById('puzzleFen');
                if (idEl) idEl.textContent = puzzle.id || '';
                if (ratingEl) ratingEl.textContent = puzzle.rating != null ? `${puzzle.rating}` : '';
                if (popularityEl) popularityEl.textContent = puzzle.popularity != null ? `${puzzle.popularity}` : '';
                if (fenEl) fenEl.textContent = puzzle.fen || '';

                const themesEl = document.getElementById('puzzleThemes');
                if (themesEl) {
                    themesEl.innerHTML = '';
                    (puzzle.themes || []).forEach(theme => {
                        const span = document.createElement('span');
                        span.className = 'puzzle-tag';
                        span.textContent = theme;
                        themesEl.appendChild(span);
                    });
                    if (!themesEl.children.length) {
                        const span = document.createElement('span');
                        span.textContent = 'No tags';
                        themesEl.appendChild(span);
                    }
                }

                const link = document.getElementById('puzzleGameLink');
                if (link) {
                    if (puzzle.gameUrl) {
                        link.href = puzzle.gameUrl;
                        link.style.pointerEvents = '';
                        link.style.opacity = '1';
                    } else {
                        link.href = '#';
                        link.style.pointerEvents = 'none';
                        link.style.opacity = '0.6';
                    }
                }

                details.classList.remove('hidden');
                setPuzzleStatus('Puzzle ready');
                showPuzzleBoard();
                if (puzzle.fen) {
                    applyPuzzlePosition(puzzle.fen);
                }
                if (puzzle.moves && puzzle.moves.length) {
                    gameState.puzzleSolution = puzzle.moves.slice();
                    let heroColor = determinePuzzleHeroColor();
                    if (!heroColor) {
                        if (gameState.currentPlayer === 'white') {
                            heroColor = 'black';
                        } else if (gameState.currentPlayer === 'black') {
                            heroColor = 'white';
                        } else {
                            heroColor = puzzleState.heroColor || 'white';
                        }
                    }
                    puzzleState.heroColor = heroColor;
                    gameState.currentPlayer = heroColor;
                    const shouldFlip = heroColor === 'black';
                    if (gameState.boardFlipped !== shouldFlip) {
                        gameState.boardFlipped = shouldFlip;
                        const chessboard = document.getElementById('chessboard');
                        if (chessboard) chessboard.classList.toggle('flipped', shouldFlip);
                        updateBoardUI();
                    }
                    updatePlayerIndicators();
                    updateGameStatus();
                    // Lead move: first solution move is usually opponent's reply; play it automatically
                    playPuzzleLeadMove();
                    gameState.currentPlayer = puzzleState.heroColor;
                    updatePlayerIndicators();
                    updateGameStatus();
                    if (gameState.puzzleSolution.length) {
                        const whoMoves = puzzleState.heroColor === 'black' ? 'Black to move' : 'White to move';
                        if (puzzleState.reviewMode) {
                            setPuzzleStatus(`Review mode: ${whoMoves.toLowerCase()}  play the correct moves to finish the puzzle`);
                        } else {
                            setPuzzleStatus(`${whoMoves}  find the best move`);
                        }
                    }
                } else {
                    gameState.puzzleSolution = [];
                }

            }

            function resetBoardForPuzzle() {
                clearSelection();
                gameState.history = [];
                gameState.redoHistory = [];
                gameState.moveHistory = [];
                gameState.capturedByWhite = [];
                gameState.capturedByBlack = [];
                gameState.gameOver = false;
                gameState.halfmoveClock = 0;
                gameState.repetitionMap = {};
                gameState.pendingMove = null;
                gameState.pgnVariations = {};
                gameState.pgnMoves = [];
                gameState.pgnIndex = 0;
                gameState.selectedPiece = null;
                gameState.replayMode = false;
                gameState.replayPromotionChoice = null;
                gameState.pgnSynced = true;
                gameState.puzzleSolution = [];
                puzzleState.active = false;
                puzzleState.solution = [];
                puzzleState.autoPlaying = false;
                puzzleState.heroColor = null;
                hidePuzzleSuccess();
                updatePuzzleStreakDisplay();
                const statusDetail = document.getElementById('statusDetail');
                if (statusDetail) statusDetail.textContent = 'Puzzle in progress';
                const gameStatus = document.getElementById('gameStatus');
                if (gameStatus) gameStatus.textContent = 'Puzzle Position';
                resetEvaluationGraph();
            }

            function applyPuzzlePosition(fen) {
                const board = fen ? parseFENBoard(fen) : null;
                if (!board) return;
                gameState.board = board.board;
                gameState.currentPlayer = board.turn === 'w' ? 'white' : 'black';
                puzzleState.heroColor = gameState.currentPlayer;
                gameState.enPassantTarget = board.enPassant;
                gameState.castlingRights = board.castling;
                gameState.halfmoveClock = board.halfmoveClock;
                gameState.repetitionMap = {};
                gameState.boardFlipped = board.turn === 'b';
                updateBoardUI();
                updatePlayerIndicators();
                updateGameStatus();
                const chessboard = document.getElementById('chessboard');
                if (chessboard) chessboard.classList.toggle('flipped', !!gameState.boardFlipped);
                recordRepetition();
            }

            function parseFENBoard(fen) {
                if (!fen) return null;
                const parts = fen.trim().split(/\s+/);
                if (parts.length < 4) return null;
                const rows = parts[0].split('/');
                if (rows.length !== 8) return null;
                const board = Array.from({ length: 8 }, () => Array(8).fill(''));
                for (let r = 0; r < 8; r++) {
                    let file = 0;
                    for (const ch of rows[r]) {
                        if (/[1-8]/.test(ch)) {
                            file += parseInt(ch, 10);
                        } else {
                            const color = ch === ch.toUpperCase() ? 'w' : 'b';
                            const symbol = ch.toLowerCase();
                            board[r][file] = color + symbol;
                            file += 1;
                        }
                    }
                }
                const turn = parts[1] === 'b' ? 'b' : 'w';
                const castling = {
                    wK: parts[2].includes('K'),
                    wQ: parts[2].includes('Q'),
                    bK: parts[2].includes('k'),
                    bQ: parts[2].includes('q')
                };
                const ep = parts[3] !== '-' ? algebraicToIndices(parts[3]) : null;
                const halfmoveClock = parts[4] ? parseInt(parts[4], 10) : 0;
                return { board, turn, castling, enPassant: ep, halfmoveClock };
            }

            function algebraicToIndices(square) {
                if (!square || square.length < 2) return null;
                const files = 'abcdefgh';
                const file = files.indexOf(square[0]);
                const rank = 8 - parseInt(square[1], 10);
                if (file < 0 || rank < 0 || rank > 7) return null;
                return [rank, file];
            }

            function playPuzzleLeadMove({ force = false } = {}) {
                if (!gameState.puzzleSolution || !gameState.puzzleSolution.length) return;
                const peek = gameState.puzzleSolution[0];
                if (!peek) return;
                if (!force) {
                    const coords = uciToCoords(peek);
                    if (coords) {
                        if (!gameState.board) {
                            applyPuzzlePosition(puzzleState.lastPuzzle?.fen || generateFEN());
                        }
                        const piece = gameState.board?.[coords.fr]?.[coords.fc];
                        if (piece) {
                            const moveColor = piece.startsWith('w') ? 'white' : 'black';
                            const heroColor = puzzleState.heroColor || gameState.currentPlayer;
                            if (moveColor === heroColor) {
                                return;
                            }
                        }
                    }
                }
                const uci = gameState.puzzleSolution.shift();
                removeHintHighlights();
                puzzleState.autoPlaying = true;
                const executed = executePuzzleMove(uci);
                puzzleState.autoPlaying = false;
                if (!executed) {
                    console.warn('Unable to auto-play puzzle move', uci);
                    gameState.puzzleSolution.unshift(uci);
                } else {
                    gameState.currentPlayer = puzzleState.heroColor;
                }
            }

            function ensureBoardReady() {
                const chessboard = document.getElementById('chessboard');
                if (!chessboard) return;
                const hasSquares = chessboard.children && chessboard.children.length > 0;
                if (!hasSquares || !gameState.board || !gameState.board.length) {
                    initializeBoard();
                }
            }

            function getHintCoordinates() {
                if (!gameState.puzzleSolution || !gameState.puzzleSolution.length) return null;
                const nextMove = gameState.puzzleSolution[0];
                const coords = uciToCoords(nextMove);
                if (!coords) return null;
                return coords;
            }

            function determinePuzzleHeroColor() {
                if (!Array.isArray(gameState.puzzleSolution) || !gameState.puzzleSolution.length) {
                    if (gameState.currentPlayer === 'white') return 'black';
                    if (gameState.currentPlayer === 'black') return 'white';
                    return puzzleState.heroColor || 'white';
                }
                for (let idx = 0; idx < gameState.puzzleSolution.length; idx += 1) {
                    const move = gameState.puzzleSolution[idx];
                    const coords = uciToCoords(move);
                    if (!coords) continue;
                    const piece = gameState.board?.[coords.fr]?.[coords.fc] || '';
                    if (!piece) continue;
                    if (piece.startsWith('w')) return 'black';
                    if (piece.startsWith('b')) return 'white';
                }
                if (gameState.currentPlayer === 'white') return 'black';
                if (gameState.currentPlayer === 'black') return 'white';
                return puzzleState.heroColor || 'white';
            }

            function showPuzzleHint() {
                if (!puzzleState.active || puzzleState.autoPlaying || !gameState.puzzleSolution || !gameState.puzzleSolution.length) {
                    return;
                }
                puzzleState.usedHint = true;
                const coords = getHintCoordinates();
                if (!coords) return;
                if (!gameState.hintStage) {
                    removeHintHighlights();
                    highlightSquare(coords.fr, coords.fc, 'hint-highlight-piece');
                    gameState.hintStage = 1;
                    gameState.hintCoords = coords;
                    setPuzzleStatus('Hint: consider this piece');
                } else if (gameState.hintStage === 1) {
                    removeHintHighlights();
                    highlightSquare(coords.fr, coords.fc, 'hint-highlight-piece');
                    highlightSquare(coords.tr, coords.tc, 'hint-highlight-target');
                    gameState.hintStage = 2;
                    gameState.hintCoords = coords;
                    setPuzzleStatus('Hint: move this piece here');
                } else {
                    removeHintHighlights();
                    setPuzzleStatus('Hints cleared  give it a try');
                }
            }

            function uciToCoords(uci) {
                if (!uci || uci.length < 4) return null;
                const files = 'abcdefgh';
                const fromFile = files.indexOf(uci[0]);
                const fromRank = parseInt(uci[1], 10);
                const toFile = files.indexOf(uci[2]);
                const toRank = parseInt(uci[3], 10);
                if (fromFile < 0 || toFile < 0 || isNaN(fromRank) || isNaN(toRank)) return null;
                const fr = 8 - fromRank;
                const fc = fromFile;
                const tr = 8 - toRank;
                const tc = toFile;
                if (!isInBounds(fr, fc) || !isInBounds(tr, tc)) return null;
                const promotion = uci[4] ? uci[4].toLowerCase() : null;
                return { fr, fc, tr, tc, promotion };
            }

            function moveToUci(fr, fc, tr, tc, promotion) {
                const files = 'abcdefgh';
                const from = `${files[fc]}${8 - fr}`;
                const to = `${files[tc]}${8 - tr}`;
                return `${from}${to}${promotion ? promotion.toLowerCase() : ''}`;
            }

            function findMoveMatchingUci(uci) {
                const coords = uciToCoords(uci);
                if (!coords) return null;
                const piece = gameState.board[coords.fr][coords.fc];
                if (!piece) return null;
                const rawMoves = calculateValidMoves(coords.fr, coords.fc);
                const legal = rawMoves.filter(([r, c, ep]) => !leavesKingInCheck(coords.fr, coords.fc, r, c, ep));
                const match = legal.find(([r, c]) => r === coords.tr && c === coords.tc);
                if (!match) return null;
                return {
                    fr: coords.fr,
                    fc: coords.fc,
                    tr: coords.tr,
                    tc: coords.tc,
                    promo: coords.promotion,
                };
            }

            function executePuzzleMove(uci) {
                const move = findMoveMatchingUci(uci);
                if (!move) return false;
                const prevReplayMode = gameState.replayMode;
                const prevReplayPromotion = gameState.replayPromotionChoice;
                const prevExecuting = gameState.executingPGN;
                gameState.executingPGN = true;
                gameState.replayMode = true;
                if (move.promo) {
                    gameState.replayPromotionChoice = move.promo;
                } else {
                    gameState.replayPromotionChoice = null;
                }
                try {
                    movePiece(move.fr, move.fc, move.tr, move.tc);
                } finally {
                    gameState.executingPGN = prevExecuting;
                    gameState.replayMode = prevReplayMode;
                    gameState.replayPromotionChoice = prevReplayPromotion;
                }
                return true;
            }

            async function fetchPuzzle(options = {}) {
                if (puzzleState.inFlight) return;
                if (puzzleState.active && !puzzleState.attemptRecorded && puzzleState.currentPuzzleId) {
                    const abandonReason = options.id ? 'abandoned-before-review' : 'abandoned-new-puzzle';
                    finalizeCurrentPuzzleAttempt({ success: false, reason: abandonReason });
                }
                const btn = document.getElementById('puzzleRefresh');
                const loadBtn = document.getElementById('puzzleLoadBoard');
                const copyBtn = document.getElementById('puzzleCopyFen');
                [btn, loadBtn, copyBtn].forEach(el => el.setAttribute('disabled', 'disabled'));
                const reviewBtn = document.getElementById('puzzleReview');
                if (reviewBtn) reviewBtn.setAttribute('disabled', 'disabled');
                puzzleState.inFlight = true;
                hidePuzzleSuccess();
                setPuzzleStatus('Fetching puzzle...');

                try {
                    const baseUrl = puzzleState.backendBase.replace(/\/$/, '');
                    if (options.id) {
                        const endpoint = `${baseUrl}/puzzles/${encodeURIComponent(options.id)}`;
                        const res = await fetch(endpoint, { headers: { 'Accept': 'application/json' } });
                        if (!res.ok) {
                            throw new Error(`Puzzle ${options.id} not found (status ${res.status})`);
                        }
                        const data = await res.json();
                        if (!data || !data.id) {
                            throw new Error('No puzzle returned');
                        }
                        resetBoardForPuzzle();
                        updatePuzzleDetails(data, { reviewEntry: options.useExistingQueueEntry || null });
                        if (puzzleState.reviewMode) {
                            setPuzzleStatus('Review mode: replay the solution without mistakes');
                        }
                        return;
                    }

                    const baseRating = Number.isFinite(puzzleState.playerRating)
                        ? Math.round(puzzleState.playerRating)
                        : 1500;
                    let windowSize = Number.isFinite(options.ratingWindow)
                        ? Math.max(0, Math.round(options.ratingWindow))
                        : 100;
                    let ratingMin = Number.isFinite(options.ratingMin)
                        ? Math.round(options.ratingMin)
                        : baseRating - windowSize;
                    let ratingMax = Number.isFinite(options.ratingMax)
                        ? Math.round(options.ratingMax)
                        : baseRating + windowSize;

                    let lastError = null;
                    let lastResponse = null;
                    for (let attempts = 0; attempts < 6; attempts += 1) {
                        const params = new URLSearchParams();
                        const minClamp = Math.max(0, ratingMin);
                        const maxClamp = Math.max(minClamp, ratingMax);
                        params.set('ratingMin', `${minClamp}`);
                        params.set('ratingMax', `${maxClamp}`);
                        if (options.theme) params.set('theme', options.theme);

                        const endpoint = `${baseUrl}/puzzles/random?${params}`;
                        const res = await fetch(endpoint, { headers: { 'Accept': 'application/json' } });
                        lastResponse = res;
                        if (!res.ok) {
                            lastError = new Error(`Backend responded ${res.status}`);
                        } else {
                            const data = await res.json();
                            if (data && data.id) {
                                resetBoardForPuzzle();
                                updatePuzzleDetails(data);
                                lastError = null;
                                break;
                            }
                            lastError = new Error('No puzzle returned');
                        }

                        const prevWindow = Math.max(
                            windowSize,
                            Math.round((Math.abs(ratingMax - ratingMin)) / 2)
                        );
                        windowSize = nextRatingWindowSize(prevWindow);
                        ratingMin = baseRating - windowSize;
                        ratingMax = baseRating + windowSize;
                    }

                    if (lastError) {
                        if (lastResponse && lastResponse.ok) {
                            throw new Error('No puzzles found near your rating. Try again later.');
                        }
                        throw lastError;
                    }
                } catch (err) {
                    console.error('Failed to load puzzle', err);
                    setPuzzleStatus(`Failed to load puzzle: ${err.message}`, true);
                    const details = document.getElementById('puzzleDetails');
                    if (details) details.classList.add('hidden');
                    hidePuzzleBoard();
                    if (options.id && options.useExistingQueueEntry && options.useExistingQueueEntry.id) {
                        queuePuzzleForReview(options.useExistingQueueEntry);
                    }
                    if (options.id) {
                        puzzleState.reviewMode = false;
                        puzzleState.reviewActiveEntry = null;
                    }
                } finally {
                    puzzleState.inFlight = false;
                    [btn, loadBtn, copyBtn, reviewBtn].forEach(el => el.removeAttribute('disabled'));
                }
            }

            async function copyPuzzleFen() {
                if (!puzzleState.lastPuzzle || !puzzleState.lastPuzzle.fen) return;
                try {
                    await navigator.clipboard.writeText(puzzleState.lastPuzzle.fen);
                    setPuzzleStatus('FEN copied to clipboard');
                } catch (err) {
                    setPuzzleStatus('Unable to copy FEN', true);
                }
            }

            function openPuzzleInAnalysis({ engine = false } = {}) {
                if (!puzzleState.lastPuzzle) return;
                const currentFen = generateFEN();
                const currentMoves = (gameState.moveHistory || []).map(move => move.notation).filter(Boolean);
                pendingAnalysisLoad = {
                    fen: currentFen,
                    pgn: (gameState.moveHistory || []).length ? buildPGN() : null,
                    engine,
                };
                puzzleState.active = false;
                puzzleState.autoPlaying = false;
                hidePuzzleSuccess();
                removeHintHighlights();
                const targetHash = engine ? '#analysis-engine' : '#analysis';
                const shouldReplace = window.location.hash !== targetHash;
                navigateToAnalysis({ engine, replaceHash: shouldReplace });
            }

            function navigateToAnalysis({ engine = false, replaceHash = false } = {}) {
                const targetHash = engine ? '#analysis-engine' : '#analysis';
                if (replaceHash) {
                    history.replaceState(null, '', targetHash);
                    showAnalysis({ enableEngine: engine });
                    return;
                }
                if (window.location.hash !== targetHash) {
                    window.location.hash = targetHash;
                    return;
                }
                showAnalysis({ enableEngine: engine });
            }

            function showPuzzleBoard() {
                const wrapper = document.getElementById('puzzleBoardWrapper');
                if (!wrapper) return;
                const localContainer = document.getElementById('appContainer');
                if (!localContainer) return;
                ensureBoardReady();
                showElement(wrapper);
                if (!wrapper.contains(localContainer)) {
                    wrapper.appendChild(localContainer);
                }
                showElement(localContainer);
                const boardControls = document.getElementById('boardControls');
                hideElement(boardControls);
                const puzzleControls = document.getElementById('puzzleControls');
                showElement(puzzleControls);
                hideElement(getEl('fenPgnTools'));
                hideElement(getEl('resign'));
                hideElement(getEl('openInAnalysis'));
                hideElement(getEl('openInAnalysisEngine'));
                hideEngineVisuals();
                hidePgnVariationsContainer();
            }

            function hidePuzzleBoard() {
                const wrapper = document.getElementById('puzzleBoardWrapper');
                if (!wrapper) return;
                const localContainer = document.getElementById('appContainer');
                if (!localContainer) return;
                const wasInWrapper = wrapper.contains(localContainer);
                if (wasInWrapper) {
                    wrapper.removeChild(localContainer);
                    ensureAppContainerInBody();
                    showElement(localContainer);
                }
                hideElement(wrapper);
            }

            function showPuzzles() {
                setActiveView('puzzles');
                hideElement(startScreen);
                if (puzzleSection) {
                    showElement(puzzleSection);
                    ensureBoardReady();
                    removeHintHighlights();
                    showPuzzleBoard();
                    if (!puzzleState.lastPuzzle) {
                        fetchPuzzle();
                    } else if (puzzleState.lastPuzzle.fen) {
                        resetBoardForPuzzle();
                        applyPuzzlePosition(puzzleState.lastPuzzle.fen);
                        if (gameState.puzzleSolution && gameState.puzzleSolution.length) {
                            playPuzzleLeadMove();
                        }
                        setPuzzleStatus('Your turn  find the best move');
                    }
                }
                if (appContainer) {
                    ensureAppContainerInBody();
                    hideElement(getEl('analysisPanel'));
                    hideElement(getEl('analysisButtons'));
                    hideElement(getEl('analyzeWithEngineGlobal'));
                    hideElement(getEl('fenPgnTools'));
                    hideElement(getEl('resign'));
                    hideElement(getEl('openInAnalysis'));
                    hideElement(getEl('openInAnalysisEngine'));
                    hideElement(getEl('newGame'));
                    hideElement(getEl('boardControls'));
                    hideEngineVisuals();
                    hidePgnVariationsContainer();
                }
                setAnalysisEnabled(false, { hidePanel: true });
            }

            function applyHashNavigation() {
                const hash = window.location.hash.replace('#', '');
                const params = new URLSearchParams(window.location.search);
                const inviteGameId = params.get('gameId');
                if (inviteGameId && !onlineState.inGame) {
                    ensureOnlinePanelVisible();
                    ensureOnlineConnection();
                    if (onlineJoinInput) onlineJoinInput.value = inviteGameId;
                    sendOnlineMessage({ type: 'join', gameId: inviteGameId.replace(/[^A-Z0-9]/gi, '').toUpperCase() });
                    setOnlineStatus(`Joining game ${inviteGameId}`);
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
                if (hash === 'play') {
                    hidePuzzleBoard();
                    showPlay();
                    ensureGameHistoryVisible();
                    return;
                } else if (hash === 'computer') {
                    showComputer();
                } else if (hash === 'analysis') {
                    showAnalysis();
                } else if (hash === 'analysis-engine') {
                    showAnalysis({ enableEngine: true });
                } else if (hash === 'puzzles') {
                    showPuzzles();
                } else {
                    showHome();
                }
            }

            const bindNav = (id, target) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (window.location.hash === `#${target}`) {
                        applyHashNavigation();
                    } else {
                        window.location.hash = `#${target}`;
                    }
                });
            };

            bindNav('linkLocalPlay', 'play');
            bindNav('linkPlayComputer', 'computer');
            bindNav('linkAnalyzeGame', 'analysis');
            bindNav('linkPuzzles', 'puzzles');
            bindNav('navHome', 'home');
            bindNav('navPlay', 'play');
            bindNav('navComputer', 'computer');
            bindNav('navAnalysis', 'analysis');
            bindNav('navAnalysisEngine', 'analysis-engine');
            bindNav('navPuzzles', 'puzzles');

            const refreshBtn = document.getElementById('puzzleRefresh');
            if (refreshBtn) refreshBtn.addEventListener('click', () => fetchPuzzle());
            const hintBtn = document.getElementById('puzzleHint');
            if (hintBtn) hintBtn.addEventListener('click', showPuzzleHint);
            const historyBtn = document.getElementById('puzzleHistoryBtn');
            if (historyBtn) historyBtn.addEventListener('click', openPuzzleHistory);
            async function requestHistoryReset({ keepStreak }) {
                const confirmed = await showConfirmationDialog({
                    title: keepStreak ? 'Reset History (Keep Streak)' : 'Reset History & Streak',
                    message: keepStreak
                        ? 'Clear attempt history and review queue while keeping your current streak?'
                        : 'This will clear attempt history, review queue, and streak. Continue?',
                    confirmLabel: keepStreak ? 'Clear History' : 'Reset All',
                    cancelLabel: 'Cancel',
                });
                if (confirmed) {
                    clearPuzzleHistory({ keepStreak });
                }
            }

            const clearHistoryBtn = document.getElementById('puzzleClearHistory');
            if (clearHistoryBtn) clearHistoryBtn.addEventListener('click', () => requestHistoryReset({ keepStreak: false }));

            const clearHistoryKeepStreakBtn = document.getElementById('puzzleClearHistoryKeepStreak');
            if (clearHistoryKeepStreakBtn) clearHistoryKeepStreakBtn.addEventListener('click', () => requestHistoryReset({ keepStreak: true }));
            if (historyOverlay) {
                historyOverlay.addEventListener('click', (event) => {
                    if (event.target === historyOverlay) {
                        closePuzzleHistory();
                    }
                });
            }

            if (historyCloseBtn) historyCloseBtn.addEventListener('click', closePuzzleHistory);
            if (historyCloseFooterBtn) historyCloseFooterBtn.addEventListener('click', closePuzzleHistory);
            if (historyRefreshBtn) historyRefreshBtn.addEventListener('click', refreshPuzzleHistoryView);
            if (historyTableBody) {
                historyTableBody.addEventListener('click', (event) => {
                    const target = event.target;
                    if (!(target instanceof HTMLElement)) return;
                    const action = target.dataset.historyAction;
                    const puzzleId = target.dataset.puzzleId;
                    if (action === 'load' && puzzleId) {
                        closePuzzleHistory();
                        finalizeCurrentPuzzleAttempt({ success: false, reason: 'history-load', skipQueue: true });
                        puzzleState.reviewMode = false;
                        puzzleState.reviewActiveEntry = null;
                        fetchPuzzle({ id: puzzleId });
                    }
                });
            }
            const reviewBtn = document.getElementById('puzzleReview');
            if (reviewBtn) reviewBtn.addEventListener('click', async () => {
                if (puzzleState.inFlight) return;
                const entry = dequeueNextReviewPuzzle();
                if (!entry || !entry.id) {
                    setPuzzleStatus('No puzzles to review right now');
                    return;
                }
                finalizeCurrentPuzzleAttempt({ success: false, reason: 'switch-review' });
                puzzleState.reviewMode = true;
                puzzleState.reviewActiveEntry = entry;
                await fetchPuzzle({ id: entry.id, useExistingQueueEntry: entry });
            });
            const undoPuzzleBtn = document.getElementById('undoMovePuzzle');
            if (undoPuzzleBtn) undoPuzzleBtn.addEventListener('click', () => clickUndoOrPrev());
            const redoPuzzleBtn = document.getElementById('redoMovePuzzle');
            if (redoPuzzleBtn) redoPuzzleBtn.addEventListener('click', () => clickRedoOrNext());
            const flipPuzzleBtn = document.getElementById('flipBoardPuzzle');
            if (flipPuzzleBtn) flipPuzzleBtn.addEventListener('click', () => {
                const chessboard = document.getElementById('chessboard');
                if (!chessboard) return;
                gameState.boardFlipped = !gameState.boardFlipped;
                chessboard.classList.toggle('flipped', !!gameState.boardFlipped);
            });
            const loadBoardBtn = document.getElementById('puzzleLoadBoard');
            if (loadBoardBtn) loadBoardBtn.addEventListener('click', () => openPuzzleInAnalysis({ engine: false }));
            const loadBoardEngineBtn = document.getElementById('puzzleLoadBoardEngine');
            if (loadBoardEngineBtn) loadBoardEngineBtn.addEventListener('click', () => openPuzzleInAnalysis({ engine: true }));
            const copyFenBtn = document.getElementById('puzzleCopyFen');
            if (copyFenBtn) copyFenBtn.addEventListener('click', copyPuzzleFen);
            const puzzlePlayAgainBtn = document.getElementById('puzzlePlayAgain');
            if (puzzlePlayAgainBtn) puzzlePlayAgainBtn.addEventListener('click', () => {
                hidePuzzleSuccess();
                fetchPuzzle();
            });
            const puzzleStayBtn = document.getElementById('puzzleStayHere');
            if (puzzleStayBtn) puzzleStayBtn.addEventListener('click', () => {
                hidePuzzleSuccess();
                setPuzzleStatus('Take your time reviewing the solution');
            });

            const playComputerBtn = document.getElementById('btnPlayComputer');
            const aiCancelBtn = document.getElementById('aiModalCancel');
            const aiStartBtn = document.getElementById('aiModalStart');
            const aiModal = document.getElementById('aiOpponentModal');

            if (playComputerBtn && aiModal) {
                playComputerBtn.addEventListener('click', () => {
                    openOpponentModal(playComputerBtn);
                });
            }

            if (aiCancelBtn) {
                aiCancelBtn.addEventListener('click', () => {
                    closeOpponentModal();
                    if (gameState.mode !== 'computer' && activeView === 'computer') {
                        const target = aiModalState.returnHash || lastNonComputerView || 'home';
                        window.location.hash = target ? `#${target}` : '#home';
                    }
                });
            }

            if (aiStartBtn) {
                aiStartBtn.addEventListener('click', () => {
                    const opponentId = aiModalState.selectedOpponentId;
                    const sideInput = document.querySelector('input[name="aiPlayerSide"]:checked');
                    const sideValue = sideInput ? sideInput.value : 'white';
                    if (!opponentId) {
                        alert('Please choose an opponent.');
                        return;
                    }
                    closeOpponentModal();
                    enterComputerPlayMode(opponentId, sideValue);
                });
            }

            window.addEventListener('hashchange', applyHashNavigation);
            applyHashNavigation();
        });
    </script>

    <div id="confirmOverlay" class="confirm-overlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="confirm-box">
            <h3 id="confirmTitle">Confirm Action</h3>
            <p id="confirmMessage">Are you sure?</p>
            <div class="confirm-actions">
                <button id="confirmCancelBtn">Cancel</button>
                <button id="confirmConfirmBtn" class="primary">Confirm</button>
            </div>
        </div>
    </div>

    <div id="historyOverlay" class="history-overlay" aria-hidden="true">
        <div class="history-modal" role="dialog" aria-modal="true" aria-labelledby="historyTitle">
            <header>
                <div>
                    <h3 id="historyTitle">Puzzle Attempt History</h3>
                    <span id="historyMeta"></span>
                </div>
                <button id="historyCloseBtn">Close</button>
            </header>
            <div class="history-body">
                <div id="historyEmpty" class="history-empty" hidden>No puzzle attempts yet. Start solving to build your history!</div>
                <div class="history-table-wrapper" id="historyTableWrapper" hidden>
                    <table class="history-table" aria-describedby="historyMeta">
                        <thead>
                            <tr>
                                <th scope="col">Date</th>
                                <th scope="col">Puzzle ID</th>
                                <th scope="col">Result</th>
                                <th scope="col">Rating </th>
                                <th scope="col">Streak</th>
                                <th scope="col">Mistakes</th>
                                <th scope="col">Hint?</th>
                                <th scope="col">Review</th>
                            </tr>
                        </thead>
                        <tbody id="historyTableBody"></tbody>
                    </table>
                </div>
            </div>
            <footer>
                <button id="historyRefreshBtn">Refresh</button>
                <button id="historyCloseFooterBtn" class="primary">Close</button>
            </footer>
        </div>
    </div>
</html>
